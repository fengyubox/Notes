闭包和OC中的block非常相似

闭包的写法:
  类型:(形参列表)->(返回值)
  技巧:初学者定义闭包类型,直接写()->().再填充参数和返回值
  值:
  {
      (形参) -> 返回值类型 in
      // 执行代码
  }

  如果闭包没有参数,没有返回值.in和in之前的内容可以省略
      httpTool.loadRequest({
        print("回到主线程", NSThread.currentThread());
    })

  尾随闭包写法
    如果闭包是函数的最后一个参数,则可以将闭包写在()后面
      httpTool.loadRequest() {
          print("回到主线程", NSThread.currentThread());
      }
    如果函数只有一个参数,并且这个参数是闭包,那么()可以不写,开发中建议该写法
      httpTool.loadRequest {
          print("回到主线程", NSThread.currentThread());
      }

定义闭包属性
  var callBack : (()->())?

闭包的循环引用
  swift中检测一个对象是否销毁,可以实现对象的deinit函数(相当于OC中dealloc方法)

  swift中解决循环引用的方式
    方案一:
      使用weak,对当前控制器使用弱引用
      但是因为self可能有值也可能没有值,因此weakSelf是一个可选类型,在真正使用时可以对其强制解包(该处强制解包没有问题,因为控制器一定存在,否则无法调用所在函数)

      weak var weakSelf = self
      httpTool.loadData {
          print("加载数据完成,更新界面:", NSThread.currentThread())
          weakSelf!.view.backgroundColor = UIColor.redColor()
      }
    
    方案二:(常用)
      和方案一类型,只是书写方式更加简单
      可以写在闭包中,并且在闭包中用到的self都是弱引用

      httpTool.loadData {[weak self] () -> () in
          print("加载数据完成,更新界面:", NSThread.currentThread())
          self!.view.backgroundColor = UIColor.redColor()
      }
    
    方案三:
      使用关键字unowned
      从行为上来说 unowned 更像OC中的 unsafe_unretained
      unowned 表示:即使它原来引用的对象被释放了，仍然会保持对被已经释放了的对象的一个 "无效的" 引用，它不能是 Optional 值，也不会被指向 nil

      httpTool.loadData {[unowned self] () -> () in
          print("加载数据完成,更新界面:", NSThread.currentThread())
          self.view.backgroundColor = UIColor.redColor()
      }