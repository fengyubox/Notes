因为OC完全兼容C, 所以可以在OC程序中编写C语言代码
并且可以将C语言的源文件和OC的源文件组合在一起生成可执行文件
  #import "zs.h"

import的功能和include一样, 是将右边的文件拷贝到当前import的位置
为了降低程序员的负担, 防止重复导入, 避免程序员去书写头文件卫士, 那么OC给出来一个新的预处理指令import
import优点: 会自动防止重复拷贝

Foundation.h我们称之为主头文件, 主头文件中又拷贝了该工具箱中所有工具的头文件, 我们只需要导入主头文件就可以使用该工具箱中所有的工具, 避免了每次使用都要导入一个对应的头文件
工具箱的地址: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks
规律: 所有的主头文件的名称都和工具箱的名称一致
      所有的主头文件都是导入了该工具箱中所有工具的头文件

自定义代码块可以在 资源库->Developer->Xcode->Userdata->Codesnippets下面
自定义代码块里面如果要使用变量,可以通过<#变量名(按井号)>

printf和NSLog的区别:
  NSLog会自动换行
  NSLog在输出内容时会附加一些系统信息
  NSLog和printf接收的参数不一样,oc接收oc的字符串对象,所以前面要加@

  #import <Foundation/Foundation.h>
  NSLog(@"OC hello World")
  NSLog(@"sum = %i", sum(20, 10));

#pragma mark基本使用
  - 会创建一条分割线
  #pragma mark - 枪
  #pragma mark - 士兵
  #pragma mark - 程序入口

修改项目模板
  /*
  工程名称:
  文件名称:
  创建者  :
  创建时间:
  版权    :
  修改人  :
  修改时间:
  */

  修改项目模板以及main函数中的内容
    /Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/Project Templates/Mac/Application/Command Line Tool.xctemplate/
  修改OC文件头部的描述信息
    /Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/Source/Cocoa Class.xctemplate

Xcode文档
  Xcode文档安装的位置1:
    /Applications/Xcode.app/Contents/Developer/Documentation/DocSets
    注意: 拷贝之前最好将默认的文档删除, 因为如果同时存在高版本和低版本的文档, 那么低版本的不会显示
  Xcode文档安装的位置2:
    /Users/你的用户名/Library/Developer/Shared/Documentation/DocSets
    如果没有该文件夹可以自己创建一个

面向对象
  C语言中函数分为声明和实现
  OC中定义一个类也分为声明和实现, 也就是说以后我们在OC中定义类, 就是在写类的声明和实现

  1. 如何编写类的声明
    以@interface开头 , 以@end结尾, 然后再class name对应的地方写上事物名称, 也就是类名即可
    注意: 类名的首字符必须大写
    声明一个类的目的就是为了告诉系统, 我们这个类中有哪些属性和行为
    OC类声明中属性只能在写@interface和@end之间的{}中
    注意: 编写OC类属性的时, 建议将所有属性的名称前面都加上_

    OC中的行为和C语言中的函数一样, 都是用来保存一段特定功能的代码
    C语言中定义一个函数, 分为声明和实现, 声明写在.h中, 实现写在.c中
    OC中定义一个方法, 也分为声明和实现, 声明写在@interface中, 实现写在@implementation

    C语言的函数分为两种: 内部函数和外部函数
    OC中的方法也分为两种; 类方法和对象方法
    
    类方法只能用类名调用, 对象方法只能用对象调用
    OC中的类方法用+表示, OC中的对象方法用-表示

    编写C语言函数的规律: 1.确定函数名称 2.确定形参 3.确定返回值 4.确定返回值类型
    编写OC方法也有规律, 规律和C语言一模一样

    类方法和对象方法的区别
    1. 对象方法以-开头
        类方法以+开头
    
    2. 对象方法必须用对象调用
        类方法必须用类来调用
    
    3. 对象方法中可以直接访问属性(成员变量)
        类方法中不可以直接访问属性(成员变量)
    
    4. 类方法和对象方法可以进行相互调用
        4.1对象方法中可以直接调用类方法
        4.2类方法中间接调用对象方法  (注意: 不建议这样使用)
        4.3类方法中可以直接调用其它类方法
        4.4对象方法中可以直接调用对象方法
    
    类方法的应用场景
    如果方法中没有使用到属性(成员变量), 那么能用类方法就用类方法
    类方法的执行效率比对象方法高
    
    类方法一般用于定义工具方法
      字符串查找
      文件操作
      数据库操作

    类名后面的 :NSObject 是为了让我们的Iphone类具备创建对象的能力
    @interface Iphone : NSObject
    {
      // 注意: 默认情况下, OC对象中的属性是不能直接访问的
      @public  // 只要让类中的属性公开, 以后就可以直接通过一个指向结构体的指针来操作对象中的属性
      float _model; // 型号  0
      int _cpu; // cup   0
      double _size; // 尺寸  0
      int _color; // 颜色  0
    }
    // 行为
    // 注意: OC中的方法, 如果没有形参不需要写(), 而是直接写一个;
    // 为什么OC中没有形参不需要写()呢? 因为OC方法中的()有特殊的用途, OC方法中的()是用来扩住数据类型的
    - (void)about;
    // 有返回值没有参数的, 读取短信
    - (char *)loadMessage;
    // 有返回值有参数的
    // 注意: OC中的方法如果有参数, 那么每个参数的数据类型前面必须加上一个:
    // 注意: 当前这个有参数的方法它的方法名称是signal:  冒号也是方法名称的一部分
    - (int)signal:(int)number;
    // 有返回值并且有多个参数的
    // 为了提高我们的阅读性, OC方法允许我们给每个参数添加一个标签来说明当前参数的含义
    // 注意: 标签也是方法名的一部分
    // 方法名是 sendMessageWithNumber:andContent:
    - (int)sendMessageWithNumber:(int)number andContent:(char *)content;
    // 如果你不想每次使用方法都需要创建对象开辟存储空间
    // 并且如果该方法中没有使用到属性(成员变量), 那么你可以把这个方法定义为类方法
    // 对象方法用对象调用  类方法用类调用
    // 如果定义类方法, 类方法的写法和对象方法一模一样, 除了前面的-号不同以外,
    // 只需要将对象方法的-号换成+, 那么就定义了一个类方法
    + (int)sumWithValue1:(int)value1 andValue2:(int)value2;
    + (void)demo;
    @end
  
  2. 如何编写类的实现
    以@implementation开头, 以@end结尾, 然后在class对应的地方写上声明时声明的类的名称, 必须和声明的类名一模一样
    
    @implementation Iphone
    // 行为的实现
    - (void)about
    {
      // 如果在对象方法中想访问该对象的属性, 可以直接写上_属性名称即可
      NSLog(@"型号 = %f, cpu = %i, 尺寸= %f, 颜色 = %i", _model, _cpu, _size, _color);
      // 对象方法中可以直接调用对象方法
      [self loadMessage]
    }
    - (char *)loadMessage
    {
        char *content = "老婆我们家我做主";
        return content;
    }
    - (int)signal:(int)number
    {
        NSLog(@"打电话给%i", number);
        return 1;
    }
    - (int)sendMessageWithNumber:(int)number andContent:(char *)content
    {
        NSLog(@"发短信给%i, 内容是%s", number, content);
        return 1;
    }
    + (int)sumWithValue1:(int)value1 andValue2:(int)value2
    {
      return value1 + value2;
    }
    + (void)demo
    {
      NSLog(@"demo");
    }
    @end

  3. 如何通过一个类来创建对象
    在OC中想要通过一个类来创建一个对象, 必须给类发送一个消息(好比C语言中调用函数一样)
    如何发送消息?   在OC中只要想要发送消息就先写上 [类名称/对象名称 方法名称];
    发送什么消息(调用什么方法)可以创建一个对象呢? new

    只要通过一个类调用类的new方法, 也就是给类发送一个叫做new的消息之后
    系统内部就会做3件事情
    1. 为Iphone类创建出来得对象分配存储空间
    2. 初始化Iphone类创建出来的对象中的属性
    3. 返回Iphone类创建出来的对象对应的地址

    OC中的类其实本质就是一个结构体, 所以p这个指针其实就是指向了一个结构体
    通过一个Iphone类型的指针接收了 Iphone对象的地址
    如果使用给一个指针保存了某一个对象的地址, 那么我们就称这个指针位之为某个类型的对象
    利用Iphone类型的指针保存了Iphone对象的地址, 那么我们就称Iphone类型的指针p之为Iphone对象
    Iphone *p = [Iphone new];
    p->_size = 3.5;
    p->_color = 0;
    p->_model = 4;
    p->_cpu = 1;
    NSLog(@"size = %f, color = %i, model = %f, cpu = %i", p->_size, p->_color, p->_model, p->_cpu);
  
    如果给对象发消息(如果调用对象的方法)
    [p about];
    
    注意: OC中的NSLog对C语言的字符串支持不是很好, 如果返回的是中文的C语言字符串可能输出的是乱码, 也有可能什么都不输出
    char *content = [p loadMessage];
    NSLog(@"content = %s", content);

    [p signal:13838338];
    [p sendMessageWithNumber:123456789 andContent:"hi"];

    int res = [Iphone sumWithValue1:50 andValue2:50];
    NSLog(@"res = %i", res);
  
  对象存储细节
    通过类创建对象  
      1.开辟存储空间, 通过new方法创建对象会在堆内存中开辟一块存储空间
      2.初始化所有属性
      3.返回指针地址(栈内存中)
      
    创建对象的时候返回的地址其实就是类的第0个属性的地址
    但是需要注意的是: 类的第0个属性并不是我们编写的_age, 而是一个叫做isa的属性
    isa是一个指针, 占8个字节
    
    其实类也是一个对象, 也就意味着Person也是一个对象
    平时我们所说的创建对象其实就是通过一个 类对象 来创建一个 新的对象
    类对象是系统自动帮我们创建的, 里面保存了当前对象的所有方法
    而实例对象是程序自己手动通过new来创建的, 而实例对象中有一个isa指针就指向了创建它的那个类对象

    [p eat];表示给p所指向的对象发送一条eat消息,调用对象的eat方法,此时对象会顺着内部的isa指针找到存储于类中的方法,执行。
    isa是对象中的隐藏指针,指向创建这个对象的类。
    通过isa指针我们可以在运行的时候知道当前对象是属于那个Class（类）的 
    如果是调用类方法,则会直接去类对象中查找方法,所以这也是为什么类方法的执行效率会比对象方法高的原因
    因为不需要经由实例对象的isa指针去查找
  
  局部变量和全局变量以及成员变量的区别
    成员变量
      写在类声明的大括号中的变量, 我们称之为成员变量(属性, 实例变量)
      成员变量只能通过对象来访问
      注意: 成员变量不能离开类, 离开类之后就不是成员变量 \
            成员变量不能在定义的同时进行初始化
      存储: 堆(当前对象对应的堆的存储空间中)
      存储在堆中的数据, 不会被自动释放, 只能程序员手动释放

    全局变量
      写在函数和大括号外部的变量, 我们称之为全局变量
      作用域: 从定义的那一行开始, 一直到文件末尾
      局部变量可以先定义在初始化, 也可以定义的同时初始化
      存储: 静态区
      程序一启动就会分配存储空间, 直到程序结束才会释放

    局部变量
      写在函数或者代码块中的变量, 我们称之为局部变量
      作用域: 从定义的那一行开始, 一直到遇到大括号或者return
      局部变量可以先定义再初始化, 也可以定义的同时初始化
      存储: 栈
      存储在栈中的数据有一个特点, 系统会自动给我们释放
    
  函数和方法的区别
    1. 函数属于整个文件, 方法属于某一个类
      方法如果离开类就不行
    2. 函数可以直接调用, 方法必须用对象或者类来调用
      注意: 虽然函数属于整个文件, 但是如果把函数写在类的声明中会不识别
    3. 不能把函数当做方法来调用, 也不能把方法当做函数来调用

    方法的注意点:
      1. 方法可以没有声明只有实现
      2. 方法可以只有声明没有实现, 编译不会报错, 但是运行会报错
        如果方法只有声明没有实现, 那么运行时会报: 
        (类方法)reason: '+[Person demo]: unrecognized selector sent to class 0x100001140'
        (对象方法)reason: '-[Person test]: unrecognized selector sent to instance 0x100400000'
    
    类也有一个注意点:
      类可以只有实现没有声明
      注意: 在开发中不建议这样写

  定义类时的常见错误
    1.只有类的声明，没有类的实现
    2.漏了@end
    3. @interface和@implementation嵌套
    4.成员变量没有写在括号里面
    5.方法的声明写在了大括号里面
    6.成员变量不能在{}中进行初始化、不能被直接拿出去访问
    7.方法不能当做函数一样调用
    8.OC方法只能声明在@interface和@end之间，只能实现在@implementation和@end之间。也就是说OC方法不能独立于类存在
    9.C函数不属于类，跟类没有联系，C函数只归定义函数的文件所有
    10.C函数不能访问OC对象的成员
    11.低级错误：方法有声明，但是实现的时候写成了函数
    12.OC可以没有@interface同样可以定义一个类
  
  结构体作为对象属性
    因为结构体只能在定义的时候初始化,所以在oc中有两个方法设置
    方法一: 强制转换
      stu->_birthday = (Date){1986, 1, 15};
    方法二:定义一个新的结构体,给d赋值,将d赋值给_birthday
      Date d = {1986, 1, 15};
      stu->_birthday = d;
    方法三:分别赋值
      stu->_birthday.year = 1986;
      stu->_birthday.month = 1;
      stu->_birthday.day = 15;
  
  匿名对象
    无论有没有名字, 只要调用new方法都会返回对象的地址
    每次new都会新开辟一块存储空间
    [Person new]->_age = 30;
    [Person new]->_name = @"LMJ";
    [[Person new] say];

    匿名对象的应用场景
      1 当对象只需要使用一次的时候就可以使用匿名对象
        [[Iphone new] brand];
      2 匿名对象可以作为方法的参数(实参)
        [p1 signal:[Iphone new]];
  
  封装getter和setter
    如果某一个属性只提供了getter方法, 没有提供setter方法, 我们称这个属性为只读属性
    如果某一个属性只提供了setter方法, 没有提供getter方法, 我们称这个属性为只写属性
    如果某一个属性同时提供了setter方法和getter方法, 我们称这个属性为可读可写的属性
    如果某一个属性没有提供了getter和setter,  我们称这个属性为私有属性
    
    setter方法:
      作用: 设置成员变量的值
      setter方法还有一个好处: 监听属性的变化
      格式:
      1. setter方法一定是对象方法
      2. 一定没有返回值
      3. 一定以set开头, 并且set后面跟上需要设置的成员变量的名称去掉下划线, 并且首字母大写
      4. 一定有参数, 参数类型一定和需要设置的成员变量的类型一致, 并且参数名称就是成员变量的名称去掉下划线
      - (void)setSize:(int)size;

    getter方法:
      作用: 获取成员变量的值
      格式:
      1. getter方法一定是对象方法
      2.一定有返回值, 而且返回值一定和获取的成员变量的类型一致
      3.方法名称就是获取的成员变量的名称去掉下划线
      4. 一定没有参数
      - (int)size;

    如果给属性提供了getter和setter方法, 那么访问属性就又多了一种访问方式 , 点语法
    点语法其实它的本质是调用了我们的setter和getter方法
    点语法是一个编译器的特性, 会在程序翻译成二进制的时候将.语法自动转换为setter和getter方法
    如果点语法在=号的左边, 那么编译器会自动转换为setter方法
    如果点语法在=号的右边, 或者没有等号, 那么编译器就会自动转换为getter方法
    点语法一般用于给成员变量赋值, 如果不是给成员变量赋值一般情况下不建议使用, 但是也可以使用
  
  self关键字
    self不能离开类, 离开类之后没有任何意义
    类方法中调用类方法除了可以使用类名调用以外, 还可以使用self来调用
      [self openFlahlight];
    self不仅仅可以调用我们的类方法, 还可以调用对象方法
    如果self在对象方法中, 那么self就代表调用当前对象方法的那个对象
    如果self在类方法中, 那么self就代表调用当前类方法的那个类
    总结: 我们只用关注self在哪一个方法中 , 如果在类方法那么就代表当前类, 如果在对象方法那么就代表"当前调用该方法的对象"
    注意:
      self会自动区分类方法和对象方法, 如果在类方法中使用self调用对象方法, 那么会直接报错
      不能在对象方法或者类方法中利用self调用当前self所在的方法,会造成死循环
    使用场景:
      可以用于在对象方法之间进行相互调用
      可以用于在类方法之间进行相互调用
      可以用于区分成员变量和局部变量同名的情况
        self->cpu = cpu;
  
  继承
    优点:
      提高代码的复用性
      可以让类与类之间产生关系, 正是因为继承让类与类之间产生了关系所以才有了多态
    如果子类中有和父类中同名的方法, 那么我们称之为方法重写
    继承中的方法调用顺序, 如果自己有就调用自己的, 如果自己没有就调用父类的
    如果一直找到NSObject类都没有找到, 那么就会报错
    在继承中除了对象方法可以重写, 类方法也可以重写
    在继承中方法可以重写, 但是属性(成员变量)不能重写
  
  super关键字
    利用super给父类的方法发送一个消息, 那么系统就会自动调用父类的方法
    如果以后想在子类中调用父类的方法可以使用super
    如果想在给父类方法进行扩展的同时保留父类的方法, 那么可以使用super调用父类同名的方法

    [super carameWithFlahlightStatus:status];

    super在类方法中, 一定会调用父类的类方法
    super在对象方法中, 一定会调用父类的对象方法
    可以利用super在任意方法中调用父类中的方法
  
  多态
    父类指针指向子类对象
    在编译的时候编译器只会检查当前类型对应的类中有没有需要调用的方法
    在运行时,系统会自动判断a1的真实类型
    在多态中, 如果想调用子类特有的方法必须强制类型转换为子类才能调用
      Animal *a1 = [Dog new];
      Dog *d1 = (Dog *)a1;
      [d1 dogMethod];
  
  实例变量修饰符
    @public
    >可以在其它类中访问被public修饰的成员变量
    >也可以在本类中访问被public修饰的成员变量
    >可以在子类中访问父类中被public修饰的成员变量
    
    @private
    >不可以在其它类中访问被private修饰的成员变量
    >可以在本类中访问被private修饰的成员变量
    >不可以在子类中访问父类中被private修饰的成员变量
    
    @protected
    >不可以在其它类中访问被protected修饰的成员变量
    >可以在本类中访问被protected修饰的成员变量
    >可以在子类中访问父类中被protected修饰的成员变量
    注意: 默认情况下所有的实例变量都是protected
    
    @package
    >介于public和private之间的
    如果是在其它包中访问那么就是private的
    如果是在当前代码所在的包种访问就是public的
    
    实例变量修饰符作用域: 从出现的位置开始, 一直到下一个修饰符出现
    如果没有遇到下一个实例变量修饰符, 那么就会修饰后面所有的实例变量
  
  description方法
    如果通过%@打印对象就会调用-号开头的description方法
    如果通过%@打印类对象就会调用+号开头的description方法
    class注意c是小写, 只要给类发送class消息, 就会返回当前类的类对象
      Class c = [Person class];
      NSLog(@"当前对象对应的类 = %@", c);
    只要利用%@打印某个对象, 系统内部默认就会调用父类的description方法
      NSLog(@"person = %@", p);
    调用该方法, 该方法会返回一个字符串, 字符串的默认格式 <类的名称: 对象的地址>
    可以重写description方法, 返回我们需要打印的内容
      - (NSString *)description
      {
        NSString *str = [NSString stringWithFormat:@"age = %i, name = %@, height = %f, weight = %f, tel = %@, email = %@", _age, _name, _height, _weight, _tel, _email];
        return str;
      }
    在description方法中尽量不要使用self来获取成员变量
    因为如果你经常在description方法中使用self, 可能已不小心就写成了 %@, self
    如果在description方法中利用%@输出self会造成死循环
      return [NSString stringWithFormat:@"%@", self]; // 死循环
  
  私有变量和私有方法
    实例变量(成员变量)既可以在@interface中定义, 也可以在@implementation中定义
    写在@implementation中的成员变量, 默认就是私有的成员变量, 并且和利用@private修饰的不太一样, 在@implementation中定义的成员变量在其它类中无法查看, 也无法访问
    在@implementation中定义的私有变量只能在本类中访问

    如果只有方法的实现, 没有方法的声明, 那么该方法就是私有方法
    在OC中没有真正的私有方法,因为OC是消息机制,可以通过SEL来调用
      [p performSelector:@selector(test)];
  
  property
    @porperty是一个编译器指令
    在Xocde4.4之前, 可以使用@porperty来代替getter/setter方法的声明
    也就是说我们只需要写上@porperty就不用写getter/setter方法的声明
    编译器只要看到@property, 就知道我们要生成某一个属性的getter/setter方法的声明
      @property int age;
    
    从Xcode4.4以后apple对@property进行了一个增强(不再需要synthesize), 以后只要利用一个@property就可以同时生成setter/getter方法的声明和实现
    没有告诉@property要将传入的参数赋值给谁, 默认@property会将传入的属性赋值给_开头的成员变量

    @property有一个弊端: 它只会生成最简单的getter/setter方法的声明和实现, 并不会对传入的数据进行过滤
    如果想对传入的数据进行过滤, 那么我们就必须重写getter/setter方法
    如果不想对传入的数据进行过滤, 仅仅是提供一个方法给外界操作成员变量, 那么就可以使用@property

    如果利用@property来生成getter/setter方法, 那么我们可以不写成员变量, 系统会自动给我们生成一个_开头的成员变量
    注意: @property自动帮我们生成的成员变量是一个私有的成员变量, 也就是说是在.m文件中生成的, 而不是在.h文件中生成的

    如果重写了setter方法, 那么property就只会生成getter方法
    如果重写了getter方法, 那么property就只会生成setter方法
    如果同时重写了getter/setter方法, 那么property就不会自动帮我们生成私有的成员变量

    属性修饰符
      @property(属性修饰符) 数据类型 变量名称;
      readwrite: 代表既生成getter方法,也生成setter方法,默认情况下@property就是readwrite的
        @property(readwrite) int age;
      readonly: 代表只生成getter方法不生成setter方法
        @property(readonly) NSString * name;
      getter:
        @property(getter=abc) double height;
        会生成
          - (void)setHeight:(double)height;
          - (double)abc;
        经常用于BOOL类型,一般情况下获取BOOL类型的属性的值, 我们都会将获取的方法名称改为isXXX
          @property(getter=isMarried) BOOL married;
      setter:
        @property(setter=tiZhong:) double weight;
        会生成
          - (void)setTiZhong:(double)weight;
          - (void)weight;

  synthesize(4.4之后就用不上了)
    是一个编译器指令, 它可以简化我们getter/setter方法的实现
    在@synthesize后面告诉编译器, 需要实现哪个@property生成的声明
    告诉@synthesize, 需要将传入的值赋值给谁和返回谁的值给调用者
      @synthesize age = _age;
    如果在@synthesize后面没有告诉系统将传入的值赋值给谁, 系统默认会赋值给和@synthesize后面写得名称相同的成员变量

  id类型
    id是一个数据类型, 并且是一个动态数据类型
    既然是数据类型, 所以就可以用来
    1.定义变量
    2.作为函数的参数
    3.作为函数的返回值

    默认情况下所有的数据类型都是静态数据类型
    静态数据类型的特点: 
      在编译时就知道变量的类型, 
      知道变量中有哪些属性和方法
      在编译的时候就可以访问这些属性和方法, 
      并且如果是通过静态数据类型定义变量, 如果访问了不属于静态数据类型的属性和方法, 那么编译器就会报错
    
    动态数据类型的特点:
      在编译的时候编译器并不知道变量的真实类型, 只有在运行的时候才知道它的真实类型
      并且如果通过动态数据类型定义变量, 如果访问了不属于动态数据类型的属性和方法, 编译器不会报错
    
    id == NSObject *  // 万能指针
    id和NSObject *的区别: 
      NSObject *是一个静态数据类型
      id  是一个动态数据类型
    
    通过静态数据类型定义变量, 不能调用子类特有的方法
    通过动态数据类型定义变量, 可以调用子类特有的方法
    通过动态数据类型定义的变量, 可以调用私有方法

    弊端: 由于动态数据类型可以调用任意方法, 所以有可能调用到不属于自己的方法, 而编译时又不会报错, 所以可能导致运行时的错误
    应用场景: 多态, 可以减少代码量, 避免调用子类特有的方法需要强制类型转换
    为了避免动态数据类型引发的运行时的错误, 一般情况下如果使用动态数据类型定义一个变量, 在调用这个对象的方法之前会进行一次判断, 判断当前对象是否能够调用这个方法
      if ([obj isKindOfClass:[Student class]]) {
        // isKindOfClass , 判断指定的对象是否是某一个类, 或者是某一个类的子类
        [obj eat];
      }
      或者
      if ([obj isMemberOfClass:[Student class]]) {
        // isMemberOfClass : 判断指定的对象是否是当前指定的类的实例(不包含子类)
        [obj eat];
      }
  
  new实现原理
    new做了三件事情
      1.开辟存储空间  + alloc 方法
      2.初始化所有的属性(成员变量) - init 方法
      3.返回对象的地址
    
    alloc做了什么事情: 1.开辟存储空间 2.将所有的属性设置为0 3.返回当前实例对象的地址
    init做了什么事情: 1.初始化成员变量, 但是默认情况下init的实现是什么都没有做 2.返回初始化后的实例对象地址
    alloc返回的地址, 和init返回的地址是同一个地址
    建议以后创建一个对象都使用alloc init, 这样可以统一编码格式
      Person *p = [[Person alloc] init];
  
  构造方法
    在OC中init开头的方法, 我们称之为构造方法
    构造方法的用途: 用于初始化一个对象, 让某个对象一创建出来就拥有某些属性和值

    重写init方法, 在init方法中初始化成员变量
      注意: 重写init方法必须按照苹果规定的格式重写, 如果不按照规定会引发一些未知的错误
      1.必须先初始化父类, 再初始化子类
      2.必须判断父类是否初始化成功, 只有父类初始化成功才能继续初始化子类
      3.返回当前对象的地址

      - (instancetype)init
      {
          // 1.初始化父类
          // 只要父类初始化成功 , 就会返回对应的地址, 如果初始化失败, 就会返回nil
          // nil == 0 == 假 == 没有初始化成功
          self = [super init];
          // 2.判断父类是否初始化成功
          if (self != nil) {
              // 3.初始化子类
              // 设置属性的值
              _age = 6;
          }
          // 4.返回地址
          return self;
      }

      简写方法
        - (instancetype)init
        {
            // 注意: 不要把 = 号写为 ==
            // 一定要将[super init]的返回值赋值给self
            if (self = [super init]) {
                // 初始化子类
                _age = 6;
            }
            return self;
        }

    instancetype和id的区别   
      instancetype == id == 万能指针 == 指向一个对象
      id在编译的时候不能判断对象的真实类型
      instancetype在编译的时候可以判断对象的真实类型
      id和instancetype除了一个在编译时不知道真实类型, 一个在编译时知道真实类型以外, 还有一个区别
      id可以用来定义变量, 可以作为返回值, 可以作为形参
      instancetype只能用于作为返回值
      注意: 以后但凡自定义构造方法, 返回值尽量使用instancetype, 不要使用id
    
    自定义构造方法
      其实就是自定义一个init方法
      1.一定是对象方法
      2.一定返回id/instancetype
      3.方法名称一定以init开头

      一个类可以有0个或者多个自定义构造方法
      自定义构造方法可以有1个或多个参数
      自定义构造方法中的init后面的With的W一定要大写(语法上的硬性规定)
      属性名称最好不要以new开头,可能会引发一些未知错误,方法也是

      - (instancetype)initWithAge:(int)age;
      - (instancetype)initWithName:(NSString *)name;
      - (instancetype)initWithAge:(int)age andName:(NSString *)name;
    
  类工厂方法
    用于快速创建对象的类方法, 我们称之为类工厂方法
    类工厂方法中主要用于 给对象分配存储空间和初始化这块存储空间

    规范:
    1.一定是类方法 +
    2.方法名称以类的名称开头, 首字母小写
    3.一定有返回值, 返回值是id/instancetype
    
    + (instancetype)personWithAge:(int)age
    {
        Person *p = [[Person alloc] init];
        p.age = age;
        return p;
    }

    自定义类工厂方法是苹果的一个规范, 一般情况下, 我们会给一个类提供自定义构造方法和自定义类工厂方法用于创建一个对象
      [[NSString alloc] init];
      [NSString string];
      
      [[NSString alloc] initWithString:<#(NSString *)#>];
      [NSString stringWithString:<#(NSString *)#>];
      
      [[NSArray alloc] init];
      [NSArray array];

      [NSArray alloc] initWithObjects:<#(id), ...#>, nil
      [NSArray arrayWithObjects:<#(id), ...#>, nil]
  
    类工厂方法在继承中的注意点
      注意: 以后但凡自定义类工厂方法, 在类工厂方法中创建对象一定不要使用类名来创建
        一定要使用self来创建
        self在类方法中就代表类对象, 到底代表哪一个类对象呢?
        谁调用当前方法, self就代表谁
      
      + (instancetype)person
      {
          // return [[Person alloc] init]; 会出错
          return [[self alloc] init];
      }

  类的本质
    类其实也是一个对象, 这个对象会在这个类第一次被使用的时候创建
    只要有了类对象, 将来就可以通过类对象来创建实例对象
    实例对象中有一个isa指针, 指向创建自己的类对象
    
    类对象中保存了当前对象所有的对象方法
    当给一个实例对象发送消息的时候, 会根据实例对象中的isa指针去对应的类对象中查找

    如何获取类对象
      一个类再内存中只有一份类对象
      [实例对象 class];  [类名 class];
    
    类对象的应用场景
      用于创建实例对象
        Class c1 = [p1 class];
        Person *p3 = [[c1 alloc] init];
        p3.age = 30;
      用于调用类方法
        [c1 test];

    类的启动过程
      load
        只要程序启动就会将所有类的代码加载到内存中, 放到代码区
        load方法会在当前类被加载到内存的时候调用, 有且仅会调用一次
        如果存在继承关系, 会先调用父类的load方法, 再调用子类的load方法
      initialize
        当当前类第一次被使用的时候就会调用(创建类对象的时候)
        initialize方法在整个程序的运行过程中只会被调用一次, 无论你使用多少次这个类都只会调用一次
        initialize用于对某一个类进行一次性的初始化
        initialize和load一样, 如果存在继承关系, 会先调用父类的initialize再调用子类的initialize
      以上两个方法都不可以手动调用

  SEL类型
    SEL类型的第一个作用
      配合对象/类来检查对象/类中有没有实现某一个方法
        SEL sel = @selector(setAge:);
        Person *p = [Person new];
        // 判断p对象中有没有实现-号开头的setAge:方法
        // 如果P对象实现了setAge:方法那么就会返回YES
        // 如果P对象没有实现setAge:方法那么就会返回NO
        BOOL flag = [p respondsToSelector:sel];
      respondsToSelector注意点: 如果是通过一个对象来调用该方法那么会判断该对象有没有实现-号开头的方法
      如果是通过类来调用该方法, 那么会判断该类有没有实现+号开头的方法
        flag = [Person respondsToSelector:sel1];
    SEL类型的第二个作用
      配合对象/类来调用某一个SEL方法
        SEL sel = @selector(demo);
        Person *p = [Person new];
        // 调用p对象中sel类型对应的方法
        [p performSelector:sel];
      withObject: 需要传递的参数
      注意: 如果通过performSelector调用有参数的方法, 那么参数必须是对象类型,
      也就是说方法的形参必须接受的是一个对象, 因为withObject只能传递一个对象
        SEL sel1 = @selector(signalWithNumber:);
        [p performSelector:sel1 withObject:@"13838383438"];

        SEL sel2 = @selector(setAge:);
        [p performSelector:sel2 withObject:@(5)];
        NSLog(@"age = %i", p.age);
      注意:performSelector最多只能传递2个参数
        SEL sel3 = @selector(sendMessageWithNumber:andContent:);
        [p performSelector:sel3 withObject:@"138383438" withObject:@"abcdefg"];
    SEL类型的第三个作用
      配合对象将SEL类型作为方法的形参 
        - (void)makeObject:(id)obj andSel:(SEL)sel
        {
            [obj performSelector:sel];
        }

        Car *c = [Car new];
        SEL sel = @selector(run);
        
        Person *p = [Person new];
        [p makeObject:c andSel:sel];

  Category
    通过分类给某一个类扩充方法, 也分为声明和实现两个部分
    分类的声明
      ClassName: 需要给哪个类扩充方法
      CategoryName: 分类的名称
      NewMethod: 扩充的方法

      @interface ClassName (CategoryName)
      NewMethod; //在类别中添加方法
      //不允许在类别中添加变量
      @end

    分类的实现
      ClassName: 需要给哪个类扩充方法
      CategoryName: 分类的名称
      NewMethod: 扩充的方法

      @implementation ClassName(CategoryName)
      
      NewMethod
      ... ...
      @end
    
    @interface Person (NJ)
    // 扩充方法
    - (void)playFootball;
    - (void)playBasketball;
    @end

    @implementation Person (NJ)
    // 实现扩充方法
    - (void)playFootball
    {
        NSLog(@"%s", __func__);
    }
    - (void)playBasketball
    {
        NSLog(@"%s", __func__);
    }
    @end
  
    注意点
      1.分类是用于给原有类添加方法的, 它只能添加方法, 不能添加属性(成员变量)
      2.分类中的@property, 只会生成setter/getter方法的声明, 不会生成实现以及私有的成员变量
      3.可以在分类中访问原有类中.h中的属性
      4.如果分类中有和原有类同名的方法, 会调用分类中的方法,同名方法调用顺序
        1.分类
        2.本类
        3.父类
        但在开发中尽量不要这样写
      5.如果多个分类中都有和原有类中同名的方法, 那么调用该方法的时候执行谁由编译器决定
        会执行最后一个参与编译的分类中的方法
        在Build Phases -> Compile Sources中可以查看修改编译的顺序
    
    匿名分类(延展)
      没有分类名称
      为某个类扩充一些私有的成员变量和方法
      写在原类的.m文件中

      #import "Person.h"

      @interface Person ()
      {
          int _age;
      }
      - (void)say;
      @end

      @implementation Person
      - (void)say
      {
          NSLog(@"age = %i", _age);
      }
      @end

字符串
  只需要在C语言字符串前面加上@符号, 系统就会自动将C语言字符串转换为OC字符串

  C语言中的字符串不是对象
    char *name1 = "lnj";
    char name2[] = "lmj";

  OC中的字符串是一个对象
  正是因为OC中的字符串是一个对象, 所以它就具备了很多功能

  输出C语言的字符串使用%s
    NSLog(@"content = %s", [p loadMessage]);
  输出OC的字符串使用%@,  %@就专门用于输出对象类型的
    NSLog(@"content = %@", [p loadMessage]);

  计算字符串的长度
    // "lnj"; // l n j \0
    // 不包含\0的
    // 计算出来的是个数, 而不是占用的字节数
    NSString *str = @"李南江";
    NSUInteger len = [str length];
  
  如何创建字符串对象
    通过不同的方式创建字符串,字符串对象储存的位置也不一样
    如果是通过字符串常量创建,那么字符串对象存储在常量区中
    如果是通过alloc initWithFormat/stringWithFormat创建,那么字符串对象存储在堆区中
    不同的平台存储的方式也不一样,如果是Mac平台系统会自动对字符串对象进行优化,但是如果是iOS平台就是两个对象
    不同的编译器存储的方式也不一样,如果是Xcode6以下并且是在iOS平台,那么每次alloc都会创建一个新的对象,
    如果是在Xcode6以上那么alloc多次指向同一块存储空间
    1.通过字符串常量创建
      如果是通过字符串常量创建对象,并且字符串常量的内容一致,那么如果创建多个字符串对象,
      多个对象指向同一块存储空间
      NSString *str1 = @"lnj";
    2.通过alloc init创建
      只要调用alloc就会在堆内存中开辟一块存储空间
      NSString *str2 = [[NSString alloc]initWithFormat:@"lmj"];
    3.通过类工厂方法创建/ stringWithFormat
      内部其实就是封装了alloc init
      NSString *str = [NSString stringWithFormat:@"age = %i, height = %f\n", 30, 1.75];
    4.通过alloc/initWithString
      一般情况下,只要是通过alloc或者类工厂方法创建的对象,每次都会在堆内存中开辟一块新的存储空间
      但是如果是通过alloc的initWithString方法除外,因为这个方法是通过copy返回一个字符串对象给我们
      而copy又分为深拷贝和浅拷贝,如果是深拷贝会创建一个新的对象,如果是浅拷贝不会创建一个新的对象,
      而是直接返回被拷贝的对象的地址给我们
      而initWithString正好是浅拷贝,所以无论什么平台或编译器都指向同一块存储空间
      NSString *str4 = [[NSString alloc]initWithString:@"ls"];
  
  字符串文件读写
    从文件中读取字符串
      1. 
        /*
        file: 文件路径,
        encoding: 编码英文 iOS-5988-1 中文 GBK GBK2312 , 一般情况填写UTF-8
        error: 如果读取错误, 会将错误信息保存到error中 ,如果读取正确, 就没有error = nil
        注意: 以后在OC方法中但凡看到XXXofFile的方法, 传递的一定是全路径(绝对路径)
        */
        NSString *path = @"/Users/xiaomage/Desktop/课堂共享/day17/note/lnj.txt";
        NSError *error = nil;
        NSString *str = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&error];
        if (error == nil) {
            NSLog(@"str = %@", str);
        } else {
            NSLog(@"error = %@", [error localizedDescription]);
        }
      2.
        创建URL 协议头 + 主机地址 + 文件路径
        //创建URL
        //NSString *path = @"http://www.baidu.com";
        //NSString *path = @"file://192.168.199.199/Users/NJ-Lee/Desktop/lnj.txt";
        //如果加载的资源是本机上的资源,那么URL中的主机地址可以省略
        //虽然主机地址可以省略,但是需要注意,文件路劲中最前面的/不能省略,文件路径最前面的/代表根路径
        NSString *path = @"file:///Users/NJ-Lee/Desktop/lnj.txt";
        //注意:如果是通过NSURL的fileURLWithPath:方法创建URL,那么系统会自动给我们传入的字符串添加协议头(file://),所以字符串中不需要再写file://
        //注意:开发中一般情况下,如果是访问本机的资源,创建URL的时候,建议使用fileURLWithPath方法创建
        //因为url不支持中文,如果URL中包含中文,那么无法访问;但是如果是通过fileURLWithString方法创建URL,哪怕URL中包含中文也可以进行访问,系统内部会自动对URL中包含的中文进行处理
        // NSURL *url = [NSURL fileURLWithPath:path];
        //如果URL中包含中文,又非不通过fileURLWithPath创建,也可以破
        //如果想破就必须在创建URL之前先对字符串中的中文进行处理,进行百分号编码
        path = [path stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
        NSURL *url = [NSURL URLWithString:path];
        //根据URL加载文件中的字符串
        NSString *str = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:nil];

    将字符串写入到文件中
      1.
        // atomically 如果传入YES, 字符串写入文件的过程中如果没有写完, 那么不会生成文件
        //            如果传入NO, 字符串写入文件的过程中如果没有写完, 会生成文件
        NSString *str = @"iOS0601基础班";
        NSString *path2 = @"/Users/xiaomage/Desktop/abc.txt";
        BOOL flag = [str writeToFile:path2 atomically:YES encoding:NSUTF8StringEncoding error:nil];
        NSLog(@"flag = %i", flag);
      2.
        NSString *str = @"lnj";
        // NSString *path = @"file:///Users/NJ-Lee/Desktop/未命名文件夹/abc.txt";
        // path = [path stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
        // NSURL *url = [NSURL URLWithString:path];
        
        NSString *path = @"/Users/NJ-Lee/Desktop/未命名文件夹/abc.txt";
        NSURL *url = [NSURL fileURLWithPath:path];
        [str writeToURL:url atomically:YES encoding:NSUTF8StringEncoding error:nil];
        
        //注意点:如果多次往同一个文件中写入内容,那么后一次的会覆盖前一次的
        NSString *str2 = @"xxoo";
        [str2 writeToURL:url atomically:YES encoding:NSUTF8StringEncoding error:nil];
    
  字符串比较
    比较两个字符串的"内容"是否相同
      BOOL flag = [str1 isEqualToString:str2];
    比较两个字符串的"地址"是否相同
      flag = (str1 == str2);
    比较字符串的大小
      // NSOrderedAscending  前面的小于后面的
      // NSOrderedSame,  两个字符串相等
      // NSOrderedDescending  前面的大于后面的
      switch ([str1 compare:str2]) {
          case NSOrderedAscending:
              NSLog(@"str1小于str2");
              break;
          case NSOrderedSame:
              NSLog(@"str1等于str2");
              break;
          case NSOrderedDescending:
              NSLog(@"str1大于str2");
              break;
          default:
              break;
      }
    忽略大小写进行比较
      switch ([str1 caseInsensitiveCompare:str2]) {
          case NSOrderedAscending:
              NSLog(@"str1小于str2");
              break;
          case NSOrderedSame:
              NSLog(@"str1等于str2");
              break;
          case NSOrderedDescending:
              NSLog(@"str1大于str2");
              break;
          default:
              break;
      }
  
  字符串搜索
    1.判断是否以什么开头
      本质就是从字符串的第一个字符开始匹配, 只要不匹配就返回NO
      [str hasPrefix:@"http://"]
    2.判断是否以什么结尾
      本质就是从字符串的最后一个字符开始匹配, 只要不匹配就返回NO
      [str hasSuffix:@".gif"]
    3.判断字符串中是否包含520it.com
      只要str中包含该字符串, 那么就会返回该字符串在str中的起始位置以及该字符串的长度
      location从0开始 , length从1开始
      如果str中没有需要查找的字符串, 那么返回的range的length=0, location = NSNotFound
      NSRange range = [str rangeOfString:@"lnj"];
      // if (range.location == NSNotFound) {
      if (range.length == 0) {
          NSLog(@"str中没有需要查找的字符串");
      }else{
          NSLog(@"str中有需要查找的字符串");
          NSLog(@"location = %lu, length = %lu", range.location, range.length);
      }
  
  字符串截取
    NSString *str = @"<head>desmond</head>";
    // 注意:rangeOfString是从左至右的开始查找, 只要找到就不找了
    NSUInteger location = [str rangeOfString:@">"].location + 1;
    NSUInteger length = [str rangeOfString:@"<" options:NSBackwardsSearch].location - location;
    // NSRange range = {6, 3};
    NSRange range = NSMakeRange(location, length);
    NSString *newStr = [str substringWithRange:range];

    从什么地方开始截取, 一直截取到最后
      NSString *newStr = [str substringFromIndex:6];
    从开头开始截取, 一直截取到什么位置
      NSString *newStr = [str substringToIndex:6];
  
  字符串替换
    // OccurrencesOfString: 要替换谁
    // withString: 用谁替换
    NSString *newStr = [str stringByReplacingOccurrencesOfString:@"&" withString:@"/"];

    去除首尾
      NSCharacterSet *set = [NSCharacterSet whitespaceCharacterSet];
      // 去除首尾大小写
      // NSCharacterSet *set = [NSCharacterSet uppercaseLetterCharacterSet]; 
      NSString *newStr = [str stringByTrimmingCharactersInSet:set];
  
  字符串与路径
    判断是否是绝对路径
      其实本质就是判断字符串是否以/开头
      [str isAbsolutePath]
    获取文件路径中的最后一个目录
      本质就是获取路径中最后一个/后面的内容
      NSString *newStr = [str lastPathComponent];
    删除文件路径中的最后一个目录
      本质就是删除最后一个/后面的内容, 包括/也会被删除
      NSString *newStr = [str stringByDeletingLastPathComponent];
    给文件路径添加一个目录
      本质就是在字符串的末尾加上一个/ 和指定的内容
      注意: 如果路径后面已经有了/, 那么就不会添加了,如果路径后面有多个/, 那么会自动删除多余的/, 只保留一个
      NSString *newStr = [str stringByAppendingPathComponent:@"xmg"];
    获取路径中文件的扩展名
      本质就是从字符串的末尾开始查找., 截取第一个.后面的内容
      NSString *newStr = [str pathExtension];
    删除路径中文件的扩展名
      本质就是从字符串的末尾开始查找.,删除第一个.和.后面的内容
      NSString *newStr = [str stringByDeletingPathExtension];
    给文件路径添加一个扩展名  
      本质就是在字符串的末尾加上一个.和指定的内容
      NSString *newStr = [str stringByAppendingPathExtension:@"jpg"];
  
  字符串的转换
    将字符串转换为大写
      NSString *newStr = [str uppercaseString];
    将字符串转换为小写
      NSString *newStr2 = [newStr lowercaseString];
    将字符串的首字符转换为大写 
      NSString *newStr = [str capitalizedString];
    字符串与基本数据类型的转换
      如果不是int,double,float,bool,integer,longlong这些类型就不要乱用
      int value1 = [str1 intValue];
    C语言字符串和OC字符串之间的转换
      C转OC
      char *cStr = "lnj";
      NSString *str = [NSString stringWithUTF8String:cStr];

      OC转C
      NSString *newStr = @"lmj";
      const char *cStr2 = [newStr UTF8String];
  
  NSMutableString
    继承与NSString
    NSMutableString是可变的,NSString是不可变的
    在开发中如果需要对字符串进行频繁的操作, 不要使用不可变的字符串

    NSMutableString *str = [NSMutableString string];
    [str appendString:@"lnj"];

    NSMutableString *strM = [[NSMutableString alloc] init];
    strM = [NSMutableString alloc] initWithFormat:<#(NSString *), ...#>
    strM = [NSMutableString stringWithFormat:<#(NSString *), ...#>]

    在字符串后面添加
      [strM appendString:@"/image"];
      [strM appendFormat:@"/age is %i", 10];
    删除字符串中的内容
      在开发中, 我们经常利用rangeOfString和deleteCharactersInRange方法配合起来删除指定的字符串
      1. 先查找出520在字符串中的位置
        NSRange range = [strM rangeOfString:@"520"];
      2. 删除
        [strM deleteCharactersInRange:range];
    在指定内容前前面插入内容
      insertString : 需要插入的字符串
      atIndex: 从哪里开始插入

      NSRange range = [strM rangeOfString:@"520"];
      [strM insertString:@"love" atIndex:range.location];
    替换字符串
      注意: 如果是调用NSString的字符串替换方法, 不会修改原有字符串, 而是生成一个新的字符串
      注意: 一般情况下OC方法要求传入一个参数如果没有*, 大部分都是枚举
            一般情况下如果不想使用枚举的值, 可以传入0, 代表按照系统默认的方式处理
      OccurrencesOfString: 需要替换的字符串
      withString: 用什么替换
      options: 替换时的搜索方式
      range: 搜索的范围
      返回值: 代表替换了多少个字符串
      NSUInteger count = [strM replaceOccurrencesOfString:@"520" withString:@"530" options:0 range:NSMakeRange(0, strM.length)];

数组
  NSArray是OC中的数组类,开发中建议尽量使用NSArray替代C语言中的数组
  只能存放任意OC对象, 并且是有顺序的
  不能存储非OC对象, 比如int\float\double\char\enum\struct等
  它是不可变的,一旦初始化完毕后,它里面的内容就永远是固定的, 不能删除里面的元素, 也不能再往里面添加元素

  创建数组
    NSArray *arr = [[NSArray alloc] init];
    NSArray *arr = [NSArray arrayWithObject:@"lnj"];
    // 数组中的nil是结束符,所以如果中间有nil,数组就只会赋值到nil之前
    NSArray *arr = [NSArray arrayWithObjects:@"lnj", @"lmj" ,@"jjj", @"cp", nil];
    // 简写
    NSArray *arr = @[@"lnj", @"lmj", @"jjj"];

  数组长度
    [arr count]

  获取最后一个元素
    [arr lastObject]

  获取第一个元素
    [arr firstObject]

  获取下标为1的元素
    [arr objectAtIndex:1]
    // 简写
    arr[1]

  是否包含指定元素
    [arr containsObject:@"zs"]
  
  遍历
    常规遍历
      for (int i = 0; i < arr.count; ++i) {
          NSLog(@"arr[%i] = %@", i, arr[i]);
      }

    如果是OC数组可以使用OC中的增强for循环来遍历
    逐个取出arr中的元素, 将取出的元素赋值给obj
    注意: obj的类型可以根据数组中元素的类型来写, 不一定要写NSObject
      for (NSString *obj in arr) {
          NSLog(@"obj = %@", obj);
      }

    使用OC数组的迭代器来遍历
    每取出一个元素就会调用一次block
    每次调用block都会将当前取出的元素和元素对应的索引传递给我们
    obj就是当前取出的元素, idx就是当前元素对应的索引
    stop用于控制什么时候停止遍历
      [arr enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
          if (idx == 1) {
              *stop = YES;
          }
          NSLog(@"obj = %@, idx = %lu", obj, idx);
      }];

    如果使用OC数组存储对象, 可以调用OC数组的方法让数组中所有的元素都执行指定的方法
    注意点: 如果数组中保存的不是相同类型的数据, 并且没有相同的方法, 那么会报错
    [arr makeObjectsPerformSelector:@selector(say)];
    withObject: 需要传递给调用方法的参数
    [arr makeObjectsPerformSelector:@selector(sayWithName:) withObject:@"lnj"];
  
  排序
    注意: 想使用compare方法对数组中的元素进行排序, 那么数组中的元素必须是Foundation框架中的对象, 
          也就是说不能是自定义对象
    NSArray *newArr = [arr sortedArrayUsingSelector:@selector(compare:)];

    // 该方法默认会按照升序排序
    NSArray *newArr = [arr sortedArrayWithOptions:NSSortStable usingComparator:^NSComparisonResult(Person *obj1, Person *obj2) {
        // 每次调用该block都会取出数组中的两个元素给我们
        //if (obj1.age > obj2.age) {
        //    return NSOrderedDescending;
        //}else if(obj1.age < obj2.age)
        //{
        //    return NSOrderedAscending;
        //}else
        //{
        //    return NSOrderedSame;
        //}
        return obj1.age > obj2.age;
    }];
  
  NSArray和NSString之间转换
    定义一个可变字符串保存拼接之后的结果
      NSMutableString *strM = [NSMutableString string];
    遍历数组, 取出数组中的每一个元素, 将元素添加到可变字符串中
      for (NSString *str in arr) {
          [strM appendString:str];
          // 每次添加完毕之后再添加一个-
          [strM appendString:@"-"];
      }
      [strM deleteCharactersInRange:NSMakeRange(strM.length - 1, 1)];
    
    拼接NSArray to NSString
      NSString *str = [arr componentsJoinedByString:@"**"];
    
    通过一个字符串生成一个数组,也叫做字符串切割
      NSString *str = @"lnj**lmj**jjj";
      NSArray *arr = [str componentsSeparatedByString:@"**"];
  
  NSArray文件读写
    将数组写入到文件中
      其实如果将一个数组写入到文件中之后, 本质是写入了一个XML文件
      在iOS开发中一般情况下我们会将XML文件的扩展名保存为plist
        NSArray *arr = @[@"lnj", @"lmj", @"jjj"];
        BOOL flag = [arr writeToFile:@"/Users/xiaomage/Desktop/abc.plist" atomically:YES];
      writeToFile只能写入数组中保存的元素都是Foundation框架中的类创建的对象, 如果保存的是自定义对象那么不能写入

    从文件中读取一个数组
      NSArray *newArray = [NSArray arrayWithContentsOfFile:@"/Users/xiaomage/Desktop/abc.plist"];

  NSMutableArray
    NSMutableArray *arrM = [NSMutableArray array];

    添加
    [arrM addObject:@"lnj"];

    将指定数组中的元素都取出来, 放到arrM中
    并不是将整个数组作为一个元素添加到arrM中
    [arrM addObjectsFromArray:@[@"lmj", @"jjj"]];

    以下是将整个数组作为一个元素添加
    [arrM addObject:@[@"lmj", @"jjj"]];

    插入
    [arrM insertObject:@"xcq" atIndex:1];

    插入一组数据, 指定数组需要插入的位置, 和插入多少个
    NSRange range = NSMakeRange(2, 2);
    NSIndexSet *set = [NSIndexSet indexSetWithIndexesInRange:range];
    [arrM insertObjects:@[@"A", @"B"] atIndexes:set];

    删除
    [arrM removeObjectAtIndex:0];
    [arrM removeLastObject];
    [arrM removeObject:@"A"];

    替换
    [arrM replaceObjectAtIndex:1 withObject:@"M"];

    获取
    [arrM objectAtIndex:0]
    arrM[0]

    替换
    arrM[0] = @"ZS";

    注意: 不能通过@[]来创建一个可变数组, 因为@[]创建出来的是一个不可变的数组
          如果把一个不可变数组当做一个可变数组来使用, 会引发一个运行时的错误

NSDictionary
  创建
    NSDictionary *dict = [NSDictionary dictionaryWithObject:@"lnj" forKey:@"name"];

    注意: key和value 是一一对应
    NSDictionary *dict = [NSDictionary dictionaryWithObjects:@[@"lnj", @"30", @"1.75"] forKeys:@[@"name", @"age", @"height"]];

    NSDictionary *dict = @{@"name":@"lnj", @"age":@"30", @"height":@"1.75"};

  获取
    NSString *name = [dict objectForKey:@"name"];

  字典的遍历
    for (int i = 0; i < dict.count; ++i) {
        // 获取字典中所有的key
        NSArray *keys = [dict allKeys];
        // 取出当前位置对应的key
        NSString *key = keys[i];
        NSString *value = dict[key];
        NSLog(@"key = %@, value = %@", key, value);
    }

    for (NSString *key in dict) {
        NSString *value = dict[key];
        NSLog(@"key = %@, value = %@", key, value);
    }

    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
        NSLog(@"key = %@, value = %@", key, obj);
    }];

  字典文件读写
    写
      NSDictionary *dict = @{@"name":@"lnj", @"age":@"30", @"height":@"1.75"};
      // XML 扩展名plist
      [dict writeToFile:@"/Users/xiaomage/Desktop/info.plist" atomically:YES];
    
    读
      // 注意: 字典和数组不同, 字典中保存的数据是无序的
      NSDictionary *newDict = [NSDictionary dictionaryWithContentsOfFile:@"/Users/xiaomage/Desktop/info.plist"];
  
  NSMutableDictionary
    创建
       NSMutableDictionary *dictM = [NSMutableDictionary  dictionary];
    添加
      [dictM setObject:@"lnj" forKey:@"name"];
      // 会将传入字典中所有的键值对取出来添加到dictM中
      [dictM setValuesForKeysWithDictionary:@{@"age":@"30", @"height":@"1.75"}];
    获取
      dictM[@"name"]
    删除
      [dictM removeObjectForKey:@"name"];
      [dictM removeObjectsForKeys:@[@"age", @"height"]];
    修改
      如果利用setObject方法给同名的key赋值, 那么新值会覆盖旧值
      [dictM setObject:@"88" forKey:@"age"];
      // 以下方法等同于setObject,所以新值也会覆盖旧值
      dictM[@"age"] = @"88";
    注意点
      不能使用@{}来创建一个可变的字典
      如果是不可变字典, 那么key不能相同
      如果是不可变字典出现了同名的key, 那么后面的key对应的值不会被保存
      如果是在可变字典中, 后面的会覆盖前面的
        NSDictionary *dict = @{@"name":@"lmj", @"name":@"lnj"};
        NSMutableDictionary *dictM = [NSMutableDictionary dictionaryWithObjects:@[@"lmj", @"lnj"] forKeys:@[@"name", @"name"]];

OC中的常用结构体
  NSPoint 保存坐标的
    NSPoint等同于CGPoint
    CGPoint point = NSMakePoint(10, 20);
  NSSize 保存尺寸的
    NSSize等同于CGSize
    CGSize size = NSMakeSize(100, 50);
  NSRect 保存坐标和尺寸
    NSRect等同于CGRect
    CGRect rect = NSMakeRect(10, 20, 100, 50);
  
  在开发中苹果推荐我们使用CG开头的结构体, 也就是说NS开头的结构体一般不用

NSNumber
  将基本数据类型转换为对象类型
    NSNumber *ageN = [NSNumber numberWithInt:age];
    NSNumber *numberN = [NSNumber numberWithDouble:number];
    NSNumber *valueN = [NSNumber numberWithInt:value];
  基本数据类型转换对象类型简写
    如果传入的是变量那么必须在@后面写上(), 如果传入的常量, 那么@后面的()可以省略
    NSNumber *temp = @(number);
    NSNumber *temp  =@10.10;
  将对象类型转换为基本数据类型
    int temp = [ageN intValue];
    double temp = [numberN doubleValue];

NSValue
  利用NSValue包装常用的结构体
    CGPoint point = NSMakePoint(10, 20);
    NSValue *value = [NSValue valueWithPoint:point];
    NSArray *arr = @[value];
  利用NSValue包装自定义的结构体
    typedef struct{
        int age;
        char *name;
        double height;
    } Person;

    Person p = {30, "lnj", 1.75};
    // valueWithBytes: 接收一个指针, 需要传递需要包装的结构体的变量的地址
    // objCType: 需要传递需要包装的数据类型
    NSValue *pValue = [NSValue valueWithBytes:&p objCType:@encode(Person)];
    NSArray *arr = @[pValue];
  从NSValue中取出自定义的结构体变量
    Person res;
    [pValue getValue:&res];

NSDate
  创建和基本概念
    只要是通过date方法创建的时间对象, 对象中就保存了当前的时间
    NSDate *now = [NSDate date];
  在now的基础上追加多少秒
    NSDate *date = [now dateByAddingTimeInterval:10];
  获取当前所处的时区
    NSTimeZone *zone = [NSTimeZone systemTimeZone];
  获取当前时区和指定时区的时间差
    NSInteger seconds = [zone secondsFromGMTForDate:now];
  时间格式化  NSDate --> NSString
    // 创建一个时间格式化对象
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    // 告诉时间格式化对象, 按照什么样的格式来格式化时间
    // yyyy 年
    // MM 月
    // dd 日
    // HH 24小时  hh 12小时
    // mm 分钟
    // ss 秒钟
    // Z 时区
    formatter.dateFormat = @"yyyy年MM月dd日 HH时mm分ss秒 Z";
    // 利用时间格式化对象对时间进行格式化
    NSString *res = [formatter stringFromDate:now];
  NSString --> NSDate
    NSString *str = @"2015-06-29 07:05:26 +0000";
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    // 注意: 如果是从NSString格式化为NSDate, 那么dateFormat的格式, 必须和字符串中的时间格式一致, 否则可能转换失败
    formatter.dateFormat = @"yyyy-MM-dd HH:mm:ss Z";
    NSDate *date = [formatter dateFromString:str];

NSCalendar
  日历
    NSDate *now = [NSDate date];
    NSCalendar *calendar1 = [NSCalendar currentCalendar];
    // 利用日历类从当前时间对象中获取 年月日时分秒(单独获取出来)
    // components: 参数的含义是, 问你需要获取什么?
    // 一般情况下如果一个方法接收一个参数, 这个参数是是一个枚举 , 那么可以通过|符号, 连接多个枚举值
    NSCalendarUnit type = NSCalendarUnitYear |
                          NSCalendarUnitMonth |
                          NSCalendarUnitDay |
                          NSCalendarUnitHour |
                         NSCalendarUnitMinute |
                        NSCalendarUnitSecond;
    NSDateComponents *cmps = [calendar1 components:type fromDate:now];
    NSLog(@"year = %ld", cmps.year);
    NSLog(@"month = %ld", cmps.month);
    NSLog(@"day = %ld", cmps.day);
    NSLog(@"hour = %ld", cmps.hour);
    NSLog(@"minute = %ld", cmps.minute);
    NSLog(@"second = %ld", cmps.second);
  比较两个时间之间的差值, 比较相差多少年多少月多少日多少小时多少分钟多少秒,步骤
    1. 过去的一个时间
      NSString *str = @"2015-06-29 07:05:26 +0000";
      NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
      formatter.dateFormat = @"yyyy-MM-dd HH:mm:ss Z";
      NSDate *date = [formatter dateFromString:str];
    2. 当前的时间
      NSDate *now = [NSDate date];
    3. 比较两个时间
      NSCalendar *calendar = [NSCalendar currentCalendar];
      NSCalendarUnit type = NSCalendarUnitYear |
      NSCalendarUnitMonth |
      NSCalendarUnitDay |
      NSCalendarUnitHour |
      NSCalendarUnitMinute |
      NSCalendarUnitSecond;
      NSDateComponents *cmps = [calendar components:type fromDate:date toDate:now options:0];
      NSLog(@"相差了%ld年%ld月%ld日%ld小时%ld分钟%ld秒钟", cmps.year, cmps.month, cmps.day, cmps.hour, cmps.minute, cmps.second);

NSFileManager
  NSFileManager *manager = [NSFileManager defaultManager];

  判断一个文件或者文件夹是否存在
    BOOL flag = [manager fileExistsAtPath:@"/Users/xiaomage/Desktop/video/01-NSArray基本概念.mp4"];
  判断一个文件是否存在, 并且判断它是否是一个文件夹  
    注意: 该方法的返回值是说明传入的路径对应的文件或文件夹是否存在
          第二个参数是用于保存判断结果的, 如果是一个目录, 那么就会赋值为YES, 如果不是就赋值为NO
    BOOL dir = NO;
    BOOL flag = [manager fileExistsAtPath:@"/Users/xiaomage/Desktop/video/01-NSArray基本概念.mp4" isDirectory:&dir];
  获取文件或文件夹的属性
    NSDictionary *info = [manager attributesOfItemAtPath:@"/Users/xiaomage/Desktop/video/01-NSArray基本概念.mp4" error:nil];
  获取文件夹中所有的文件
    注意:contentsOfDirectoryAtPath方法有一个弊端, 只能获取当前文件夹下所有的文件, 不能获取子文件夹下面的文件
    NSArray *res = [manager contentsOfDirectoryAtPath:@"/Users/xiaomage/Desktop/video" error:nil];
    // 以下两个方法就可以查看到包括子文件下面的所有文件
    NSArray *res = [manager subpathsAtPath:@"/Users/xiaomage/Desktop/video"];
    NSArray *res = [manager subpathsOfDirectoryAtPath:@"/Users/xiaomage/Desktop/video" error:nil];
  创建文件夹
    // createDirectoryAtPath: 告诉系统文件夹需要创建到什么位置
    // withIntermediateDirectories: 如果指定的文件中有一些文件夹不存在, 是否自动创建不存在的文件夹
    // attributes: 指定创建出来的文件夹的属性
    // error: 是否创建成功, 如果失败会给传入的参数赋值
    // 注意: 该方法只能用于创建文件夹, 不能用于创建文件
    BOOL flag = [manager createDirectoryAtPath:@"/Users/xiaomage/Desktop/abc/lnj" withIntermediateDirectories:YES attributes:nil error:nil];
  创建文件
    // createFileAtPath: 指定文件创建出来的位置
    // contents : 文件中的内容
    // attributes: 创建出来的文件的属性
    // NSData : 二进制数据
    // 注意: 该方法只能用于创建文件, 不能用于创建文件夹
    NSString *str = @"江哥真帅";
    NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];
    [manager createFileAtPath:@"/Users/xiaomage/Desktop/abc.txt" contents:data attributes:nil];

内存管理
  只要创建一个对象默认引用计数器的值就是1
  只要给对象发送一个retain消息, 对象的引用计数器就会+1
  只要对象接收到release消息, 引用计数器就会-1
  只要对象接收到retainCount消息, 就会返回当前的引用计数
  只要一个对象的引用计数器为0, 系统就会释放对象
  注意: release并不代表销毁\回收对象, 仅仅是计数器-1

  ARC: Automatic(自动) Reference(引用) Counting(计数)
  什么是自动引用计数? 
  不需要程序员管理内容, 编译器会在适当的地方自动给我们添加release/retain等代码
  注意点: OC中的ARC和java中的垃圾回收机制不太一样, java中的垃圾回收是系统干的, 而OC中的ARC是编译器干的
  
  MRC: Manul(手动) Reference(引用) Counting(计数)
  什么是手动引用计数?
  所有对象的内容都需要我们手动管理, 需要程序员自己编写release/retain等代码
  
  内存管理的原则就是有加就有减
  也就是说, 一次alloc对应一次release, 一次retain对应一次relese

  类定义dealloc,当对象释放时会执行
  - (void)dealloc
  {
      // 等同于NSLog(@"Person dealloc");
      NSLog(@"%s", __func__);
      // 注意:super dealloc一定要写到所有代码的最后
      // 一定要写在dealloc方法的最后面
      [super dealloc];
  }

  野指针&空指针
    只要一个对象被释放了, 我们就称这个对象为 "僵尸对象"
    当一个指针指向一个僵尸对象, 我们就称这个指针为野指针
    只要给一个野指针发送消息就会报错

    空指针  nil  0
    为了避免给野指针发送消息会报错, 一般情况下, 当一个对象被释放后我们会将这个对象的指针设置为空指针
    因为在OC中给空指针发送消息是不会报错的
  
  多个对象的内存管理
    当A对象想使用B对象一定要对B对象进行一次retain, 这样才能保证A对象存在B对象就存在, 也就是说这样才能保证无论在什么时候在A对象中都可以使用B对象
    当A对象释放的时候, 一定要对B对象进行一次release, 这样才能保证A对象释放了, B对象也会随之释放, 避免内存泄露
    总结一句话: 有增就有减
  
    Set方法的内存管理
      - (void)setRoom:(Room *)room // room = r
      {
          // 只有房间不同才需用release和retain
          if (_room != room) {// 0ffe1 != 0ffe1
              
              // 将以前的房间释放掉 -1
              [_room release];
              
              // retain不仅仅会对引用计数器+1, 而且还会返回当前对象
              _room = [room retain];
          }
      }

      - (void)dealloc
      {
          // 人释放了, 那么房间也需要释放
          [_room release];
          NSLog(@"%s", __func__);
          [super dealloc];
      }
  
    property修饰符
      retain: 就会自动帮我们生成getter/setter方法内存管理的代码
      assign: 不会帮我们生成set方法内存管理的代码, 仅仅只会生成普通的getter/setter方法,默认什么都不写就是assign

      OC本身的对象类型使用assign即可,因为是放在栈中(int, struct, bool等)
      非OC本身的对象类型就是用retain(NSString,自定义的类型等)
      
      多线程
      atomic ：性能低（默认）
      nonatomic ：性能高
      在iOS开发中99.99%都是写nonatomic

      相同类型的property修饰符不能同时使用
      不同类型的property修饰符可以多个结合在一起使用, 多个之间用,号隔开
      iOS开发中只要写上property, 那么就立刻写上nonatomic

    dealloc最简洁的写法
      - (void)dealloc
      {
        // 下面这句话相当于调用了set方法
        // 先release旧值, 然后再将新值赋值给属性
        self.text = nil;
        self.picture = nil;
        self.author = nil;
        self.repostStatus = nil;
      }
    
    循环retain
      如果A对用要拥有B对象, 而B对应又要拥有A对象, 此时会形成循环retain
      如何解决这个问题: 不要让A retain B, B retain A
      让其中一方不要做retain操作即可
  
  autorelease
    不用关心对象什么时候释放, 只要能够访问p的地方都可以使用p
    自动释放池本质就只是将release延迟了而已
    @autoreleasepool { // 创建一个自动释放池
      Person *p = [[Person alloc] init]; // 1 
      p = [p autorelease]; // 只要调用了autorelease,就会将对象置入自动释放池中,那么就不用调用release了
        
      [p run];
    } // 自动释放池销毁了, 给自动释放池中所有的对象发送一条release消息

    autorelease其它写法
      @autoreleasepool {
          Person *p  = [[[Person alloc] init] autorelease];
          [p run];
      }
    
    autorelease注意事项
      1.一定要在自动释放池中调用autorelease, 才会将对象放入自动释放池中
      2.在自动释放池中创建了对象, 一定要调用autorelease,才会将对象放入自动释放池中
      3.只要在自动释放池中调用autorelease, 就会将对象放入自动释放池
      4.不要再自动释放池中使用比较消耗内存的对象, 占用内存比较大的对象
        @autoreleasepool {
            Person *p = [[[Person alloc] init] autorelease];
            
            // 假如p对象只在100行的地方使用, 以后都不用了
            
            // 一万行代码
        }
      5.尽量不要再自动释放池中使用循环, 特别是循环的次数非常多, 并且还非常占用内存
        @autoreleasepool {
            for (int i = 0; i < 99999; ++i) {
                // 每调用一次都会创建一个新的对象
                // 每个对象都会占用一块存储空间
                Person *p = [[[Person alloc] init] autorelease];
            }
        } 
        可以使用
        for (int i = 0; i < 99999; ++i) {
            @autoreleasepool {
                Person *p = [[[Person alloc] init] autorelease];
            } // 执行到这一行, 自动释放池就释放了
        }
      6.一个程序中可以创建N个自动释放池, 并且自动释放池还可以嵌套
        如果存在多个自动释放池的时候, 自动释放池是以 "栈" 的形式存储的
      7.千万不要写多次autorelease,一个alloc, new对应一个autorelease
        如果写了autorelease就不要写release
        总之记住: 一个alloc/new对应一个autorelease或者release

    auatorelease应用场景
      + (instancetype)personWithAge:(int)age
      {
          return [[[self alloc] initWithAge:age] autorelease];
      }

      @autoreleasepool {
        Person *p = [Person personWithAge:10];
      }

      Foundation框架的类, 但凡是通过类工厂方法创建的对象都是autorelease的
  
  ARC 
    ARC的判断准则: 只要没有强指针指向对象, 对象就会释放
    默认情况下所有的指针都是强指针
      __strong Person *p = [[Person alloc] init];

    在开发中, 千万不要使用一个弱指针保存一个刚刚创建的对象,因为对象会立即释放
      __weak Person *p2 = p;
    
    单个内存管理 
      Person *p = [[Person alloc] init];
      // 不想要对象时直接将栈中指针赋值为空指针即可
      p = nil;
    
    多个内存管理
      MRC, A对象想拥有B对象, 需要对B对象进行一次retain
          A对象不用B对象了, 需要对B对象进行一次release
          property的时候进行retain, dealloc的时候进行release


      ARC, A对象想拥有B对象, 那么就需要用一个强指针指向B对象
          A对象不用B对象了, 什么都不需要做, 编译器会自动帮我们做

      // 在ARC中保存一个对象用strong, 相当于MRC中的retain
      @property(nonatomic, strong)Dog *dog;
    
      ARC中循环引用的问题同MRC一样, 让其中一方不要是strong即可
      在ARC中如果保存对象不要用assign, 用weak
      assign是专门用于保存基本数据类型的, 如果保存对象用weak
      @property(nonatomic, weak)Person *owner;

  集合对象的内存管理
    MRC下才需要考虑
    如果将一个对象添加到一个数组中, 那么数组会对对象进行一个retain
    当数组对象释放之后, 会给数组中所有的对象发送一条release消息
    当数组移除一个对象之后, 会给这个对象发送一条release消息
  
  // 如何判断当前是ARC还是MRC?
  // 可以在编译的时候判断当前是否是ARC
  #if __has_feature(objc_arc)
      NSLog(@"ARC");
  #else
      NSLog(@"MRC");
  #endif

@class
  // 取代 #import "Car.h"
  @class Car;

  由于import是一个预编译指令, 他会将""中的文件拷贝到import所在的位置
  并且import有一个特点, 只要""中的文件发生了变化, 那么import就会重新拷贝一次(更新操作)

  @class仅仅是告诉编译器, @class后面的名称是一个类, 不会做任何拷贝操作
  注意: 由于@class仅仅是告诉编译器后面的名称是一个类, 所以编译器并不知道这个类中有哪些属性和方法, 所以在.m中使用这个类时需要import这个类, 才能使用

  作用1 提升编译效率
    1.如果都在.h中import, 假如A拷贝了B, B拷贝了C ,  如果C被修改了, 那么B和A都需要重新拷贝. 因为C修改了那么B就会重新拷贝, 而B重新拷贝之后相当于B也被修改了, 那么A也需要重新拷贝. 也就是说如果都在.h中拷贝, 只要有间接关系都会重新拷贝
    2.如果在.h中用@class, 在.m中用import, 那么如果一个文件发生了变化, 只有和这个文件有直接关系的那个文件才会重新拷贝
    3.所以在.h中用@class可以提升编译效率
  
  作用2 解决循环引用
    如果两个类相互拷贝, 例如A拷贝B, B拷贝A, 这样会报错
    如何解决: 在.h中用@class, 在.m中用import
    因为如果.h中都用import, 那么A拷贝B, B又拷贝A, 会形成死循环
    如果在.h中用@class, 那么不会做任何拷贝操作, 而在.m中用import只会拷贝对应的文件, 并不会形成死循环
  
block
  block是一种数据类型

  // 指向函数的指针
  // void代表指向的函数没有返回值
  // ()代表指向的函数没有形参
  // (*roseP)代表roseP是一个指向函数的指针
  void (*roseP) ();
  roseP = printRose;
  roseP();

  block和函数一样,可以没有返回值,也没有形参
  也可以没有返回值有形参
  也可以有返回值没有形参
  也可以有返回值有形参
  所以, 在定义一个block变量的时候, 也需要告诉该变量将来保存的代码有没有返回值和形参  
  // 定义一个block变量
  // void代表block将来保存的代码没有返回值
  // ()代表block将来保存的代码没有形参
  // (^roseBlock) 代表reseBlock是一个block变量, 可以用于保存一段block代码
  void (^roseBlock) ();
  // 如果block没有参数, 那么^后面的()可以省略
  roseBlock = ^(){
      printf("  {@} \n");
      printf("   |  \n");
      printf("  \\|/ \n");
      printf("   | \n");
  };
  // 要想执行block保存的代码, 必须调用block才会执行
  roseBlock();

  //有形参的例子
  void (^roseBlock) (int);
  roseBlock = ^(int num){
      for (int i = 0; i < num; ++i) {
          
          printf("  {@} \n");
          printf("   |  \n");
          printf("  \\|/ \n");
          printf("   | \n");
      }
  };
  roseBlock(2);

  //更简洁的定义方式
  int (^printBlock)(int)= ^int (int num){
      for (int i=0; i<num; ++i) {
          printf("--------\n");
      }
      return 1;
  }
  printBlock(2);

  利用typedef给block起别名, 和指向函数的指针一样, block变量的名称就是别名
    typedef int (^calculteBlock)(int , int);

    calculteBlock sumBlock = ^(int value1, int value2){
        return value1 + value2;
    };

    calculteBlock minusBlock = ^(int value1, int value2){
        return value1 - value2;
    };

    sumBlock(20, 10);
    minusBlock(20, 10);

  应用场景
    当发现代码的前面和后面都是一样的时候, 这个时候就可以使用block
    void goToWork(void (^workBlock)())
    {
        NSLog(@"起床");
        NSLog(@"穿衣服");
        NSLog(@"洗漱");
        NSLog(@"喝早茶");
        NSLog(@"驾车去上班");
        
        // 不一样
        workBlock();
        
        NSLog(@"收拾东西");
        NSLog(@"驾车回家");
        NSLog(@"吃晚饭");
        NSLog(@"洗澡");
        NSLog(@"睡觉");
    }

    void goToWorkInDay1()
    {
        goToWork(^{
            NSLog(@"认识新同事");
        });
    }

    void goToWorkInDay2()
    {
        goToWork(^{
            NSLog(@"熟悉公司代码");
        });
    }
  
  注意事项
    1.block中可以访问外面的变量
      int a = 10;
      void (^myBlock)() = ^{
          NSLog(@"a = %i", a);
      };
      myBlock();
    2.block中可以定义和外界同名的变量, 并且如果在block中定义了和外界同名的变量, 
      在block中访问的是block中的变量
    3.默认情况下, 不可以在block中修改外界变量的值
      因为block中的变量和外界的变量并不是同一个变量
      如果block中访问到了外界的变量, block会将外界的变量拷贝一份到堆内存中
      因为block中使用的外界变量是copy的, 所以在调用之前修改外界变量的值, 不会影响到block中copy的值
    4.如果想在block中修改外界变量的值, 必须在外界变量前面加上__block
      此时如果在block中修改了外界变量的值, 会影响到外界变量的值
      __block int a = 10;
      NSLog(@"&a = %p", &a);
      void (^myBlock)() = ^{
          a = 50;
          NSLog(@"&a = %p", &a);
          NSLog(@"a = %i", a);
      };
      myBlock();

      如果没有添加__block是值传递
      如果加上__block之后就是地址传递, 所以可以在block中修改外界变量的值
    5.默认情况下block存储在栈中, 如果对block进行一个copy操作( Block_copy(myBlock) ), block会转移到堆中
      如果block在栈中, block中访问了外界的对象, 那么不会对对象进行retain操作
      但是如果block在堆中, block中访问了外界的对象, 那么会对外界的对象进行一次retain
    6.如果在block中访问了外界的对象, 一定要给对象加上__block, 只要加上了__block, 哪怕block在堆中, 也不会对外界的对象进行retain
      如果是在ARC开发中就需要在前面加上__weak
      // 如果在做iOS开发时, 在ARC中不这样写容易导致循环引用
      Person *p = [[Person alloc] init];
      __weak Person *weakP = p;

protocol
  一个protocol是由一系列的方法声明组成的

  Protocol的定义
    @protocol 协议名称
    // 方法声明列表
    @end
  
  一个类可以遵守1个或多个协议,任何类只要遵守了Protocol,就相当于拥有了Protocol的所有方法声明
    @interface 类名 : 父类 <协议名称1, 协议名称2,…>
    @end
  
  protocol和继承区别
    继承之后默认就有实现, 而protocol只有声明没有实现
    相同类型的类可以使用继承, 但是不同类型的类只能使用protocol
    protocol可以用于存储方法的声明, 可以将多个类中共同的方法抽取出来, 以后让这些类遵守协议即可
  
  protocol注意点
    1.协议只能声明方法, 不能声明属性
    2.父类遵守了某个协议, 那么子类也会自动遵守这个协议
    3.在OC中一个类可以遵守1个或多个协议
      OC中的类只能有一个父类, 也就是说OC只有单继承
    4.OC中的协议又可以遵守其它协议, 只要一个协议遵守了其它协议, 那么这个协议中就会自动包含其它协议的声明
    5.协议默认继承自NSObject协议,这里注意NSObject是一个基协议,跟继承中的NSObject基类是两码事
      @protocol SportProtocol <NSObject>
  
  如果协议中的方法是@required的, 而遵守协议的类又没有实现该方法, 那么会报一个警告
    @required
    - (void)playFootball;
  如果协议中的方法是@optional的, 而遵守协议的类又没有实现该方法, 那么不会报警告
    @optional
    - (void)playBasketball;
    - (void)playBaseball;
  如果没有使用任何关键字修饰协议中的方法, 那么该方法默认就是required的
  @required和@optional仅仅使用程序员之间交流, 并不能严格的控制某一个遵守该协议的类必须要实现该方法, 
  因为即便不是实现也不会报错, 只会报一个警告

  协议的应用场景
    1.类型限定
      协议的第一个应用场景, 可以将协议写在数据类型的右边, 
      明确的标注如果想给该变量赋值, 那么该对象必须遵守某个协议
      Wife<WifeCondition> *w = [Wife new];

      如果作为变量的话,也可以在property修饰符上做限定
      @property (nonatomic, strong) Wife<WifeCondition> *wife;
      p.wife = w;

      注意: 虽然在接受某一个对象的时候, 对这个对象进行了类型限定(限定它必须实现某个协议), 
      但是并不意味着这个对象就真正的实现了该方法. 所以每次在调用对象的协议方法时应该进行一次验证
        [self.wife respondsToSelector:@selector(cooking)]
    2.代理设计模式
      代理设计模式的应用场景
        1.当A对象想监听B对象的一些变化时, 可以使用代理设计模式
        保姆想监听婴儿的变化, 那么保姆就可以成为婴儿的代理, 当婴儿发生变化之后保姆就可以监听到
        
        2.当B对象发生一些事情, 想通知A对象的时候, 可以使用代理设计模式
        婴儿想通知保姆, 那么就可以让保姆成为婴儿的代理, 只要保姆成为婴儿的代理, 以后婴儿发生变化就可以通知保姆
        
        3.当对象A无法处理某些行为的时候,想让对象B帮忙处理(让对象B成为对象A的代理对象)
        婴儿无法自己吃东西, 也无法自己入睡, 所以可以让保姆帮忙处理. 只要让保姆成为婴儿的代理就可以帮婴儿喂它吃东西和哄他睡觉

      // 如果使用id类型来接收保姆, 如果将来换保姆了, 婴儿类不用修改代码
      @property (nonatomic, strong) id<BabyProtocol> nanny;
  
  协议的编写规范:
    1.一般情况下, 当前协议属于谁, 我们就将协议定义到谁的头文件中
    2.协议的名称一般以它属于的那个类的类名开头, 后面跟上protocol或者delegate
    3.协议中的方法名称一般以协议的名称protocol之前的作为开头
    4.一般情况下协议中的方法会将触发该协议的对象传递出去
    5.一般情况下一个类中的代理属于的名称叫做delegate
    6.当某一个类要成为另外一个类的代理的时候, 
      一般情况下在.h中用@protocol 协议名称;告诉当前类这是一个协议.
        在.m中用#import真正的导入一个协议的声明

    @protocol PersonProtocol <NSObject>
    - (void)personFindHourse:(Person *)person;
    @end

Copy
  利用一个源对象产生一个副本对象
  修改源对象的属性和行为，不会影响副本对象
  修改副本对象的属性和行为，不会影响源对象

  一个对象可以调用copy或mutableCopy方法来创建一个副本对象
  copy : 创建的是不可变副本(如NSString、NSArray、NSDictionary)
  mutableCopy :创建的是可变副本(如NSMutableString、NSMutableArray、NSMutableDictionary)

  使用copy功能的前提,需要遵守NSCopying协议，实现copyWithZone:方法
  使用mutableCopy的前提,需要遵守NSMutableCopying协议，实现mutableCopyWithZone:方法

  只要是拷贝出来的对象, 拷贝出来的对象中的内容和以前对象中的内容一致
  "一般"情况下拷贝会生成一个新的对象
  为什么会产生一个新的对象 
    1.因为拷贝要求修改原来的对象不能影响到拷贝出来得对象
      修改拷贝出来的对象也不能影响到原来的对象, 所以需要生成一个新的对象
    2.由于以前的对象是一个不可变的对象, 而通过mutableCopy拷贝出来的对象必须是一个可变的对象, 
      所以必须生成一个新的对象
  NSMutableString *copyStr = [srcStr mutableCopy];
  NSString *copyStr = [srcStr copy];

  如果是通过不可变对象调用了copy方法, 那么不会生成一个新的对象
  原因: 因为原来的对象是不能修改的, 拷贝出来的对象也是不能修改的
  既然两个都不能修改, 所以永远不能影响到另外一个对象, 那么已经符合需求
  所以: OC为了对内存进行优化, 就不会生成一个新的对象
  NSString *copyStr = [srcStr copy];

  正是因为调用copy方法有时候会生成一个新的对象, 有时候不会生成一个新的对象
  所以: 如果没有生成新的对象, 我们称之为浅拷贝, 本质就是指针拷贝
      如果生成了新的对象, 我们称之为深拷贝, 本质就是会创建一个新的对象
  
  Copy内存管理
    内存管理原则:
    一次alloc 对应一次release
    一次retain 对应一次 release
    一次copy 对应一次release
    有加就有减

    如果是浅拷贝:不会生成新的对象,但是系统就会对原来的对象进行retain,
    所以需要对原来的对象进行一次
    
    如果是深拷贝:会生成新的对象,系统不会对原来的对象进行retain,但是因为生成了新的对象,
    所以我们需要对新的对象进行release

    浅拷贝
      char *cstr = "this is a c string";
      NSString *str1 = [[NSString alloc] initWithUTF8String:cstr]; // 1
      // 不会产生新对象, 会对原有对象进行一次retain
      NSString *str2 = [str1 copy]; // 2
      // 注意点: 如果是浅拷贝, 那么会对拷贝的对象进行一次retain, 那么我们就需要对拷贝出来的对象进行一次release
      [str2 release]; // 1
      [str1 release]; // 0

    深拷贝
      char *cstr = "this is a c string";
      NSString *str1 = [[NSString alloc] initWithUTF8String:cstr]; // str1 1
      // 会生成一个新的对象
      NSMutableString *str2 = [str1 mutableCopy]; // str2 1
      [str1 release]; // str1 0
      [str2 release]; // str2 0
  
  Copy与Property
    copy的第一个用途, 防止外界修改内部的数据
      NSMutableString *temp = [NSMutableString stringWithFormat:@"lnj"];
      Person *p = [[Person alloc] init];
      p.name = temp;
      // 问题: 修改了外面的变量, 影响到了对象中的属性
      [temp appendString:@" cool"];

      解决方法
        @property (nonatomic, copy) NSString *name;
        以后字符串属性都用copy
    
    copy的第二个用途,可以使用copy保存block, 这样可以保住block中使用的外界对象的命
      block默认存储在栈中, 栈中的block访问到了外界的对象, 不会对对象进行retain
      block如果在堆中, 如果在block中访问了外界的对象, 会对外界的对象进行一次retain

      // 避免以后调用block的时候, 外界的对象已经释放了
      Dog *d = [[Dog alloc] init]; // 1
      Person *p = [[Person alloc] init];
      p.pBlock = ^{
          NSLog(@"%@", d);
      };

      // 如果狗在调用block之前释放了, 那么程序就会崩溃
      [d release]; // 0
      p.pBlock();
      [p release];

      解决方法
        // 注意: 如果是block使用copy并不是拷贝, 而是转移(从栈到堆)
        @property (nonatomic, copy) myBlock pBlock;

        - (void)dealloc
        {
            // 只要给block发送一条release消息, block中使用到的对象也会收到该消息
            Block_release(_pBlock);
            NSLog(@"%s", __func__);
            [super dealloc];
        }

    copy block之后引发循环引用
      如果对象中的block又用到了对象自己, 那么为了避免内存泄露, 应该将对象修饰为__block
      Person *p = [[Person alloc] init]; // 1
      p.name = @"lnj";
      p.pBlock = ^{
          NSLog(@"name = %@", p.name); // 2
      };
      p.pBlock();
      
      [p release]; // 1

      解决方法
        替换
        Person *p = [[Person alloc] init]; // 1
        为
        __block Person *p = [[Person alloc] init];
  
  自定义类实现copy
    1.以后想让自定义的对象能够被copy只需要遵守NSCopying协议
    2.实现协议中的- (id)copyWithZone:(NSZone *)zone
    3.在- (id)copyWithZone:(NSZone *)zone方法中创建一个副本对象, 然后将当前对象的值赋值给副本对象即可

      @interface Person : NSObject<NSCopying, NSMutableCopying>

      - (id)copyWithZone:(NSZone *)zone
      {
          // 1.创建一个新的对象
          Person *p = [[[self class] allocWithZone:zone] init];
          
          // 2.设置当前对象的内容给新的对象
          p.age = _age;
          p.name = _name;
          
          // 3.返回新的对象
          return p;
      }
      - (id)mutableCopyWithZone:(NSZone *)zone
      {
          // 1.创建一个新的对象
          Person *p = [[[self class] allocWithZone:zone] init];
          
          // 2.设置当前对象的内容给新的对象
          p.age = _age;
          p.name = _name;
          
          // 3.返回新的对象
          return p;
      }

    如果想让子类在copy的时候保留子类的属性, 那么必须重写copyWithZone方法, 
    在该方法中先调用父类创建副本设置值, 然后再设置子类特有的值
      - (id)copyWithZone:(NSZone *)zone
      {
          // 1.创建副本
          id obj = [super copyWithZone:zone];
          // 2.设置数据给副本
          [obj setHeight:_height];
          
          // 3.返回副本
          return obj;
      }

单例ARC和MRC写法
  单例就是无论怎么创建都只能有一个实例对象
  如果地址相同就代表着是同一个实例对象

  Tools *t1 = [[Tools alloc] init]; //内部会调用allocWithZone
  Tools *t2 = [Tools new]; // [[alloc] init]  allocWithZone
  Tools *t3 = [Tools shareInstance];
  Tools *t4 = [t3 copy];
  Tools *t5 = [t3 mutableCopy];

  一般情况下创建一个单例对象都有一个与之对应的类方法
  一般情况下用于创建单例对象的方法名称都以share开头, 或者以default开头

  @interface Tools : NSObject<NSCopying, NSMutableCopying>
  + (instancetype)shareInstance;
  @end

  @implementation Tools
  + (instancetype)shareInstance
  {
      Tools *instance = [[self alloc] init];
      return instance;
  }

  static Tools *_instance = nil;
  + (instancetype)allocWithZone:(struct _NSZone *)zone
  {
      /*
      // 当前代码在多线程中可能会出现问题
      // 由于所有的创建方法都会调用该方法, 所以只需要在该方法中控制当前对象只创建一次即可
      if (_instance == nil) {
          _instance = [[super allocWithZone:zone] init];
      }
      return _instance;
      */
      
      // 以下代码在多线程中也能保证只执行一次
      static dispatch_once_t onceToken;
      dispatch_once(&onceToken, ^{
          _instance = [[super allocWithZone:zone] init];
      });
      return _instance;
  }

  - (id)copyWithZone:(NSZone *)zone{
      return _instance;
  }

  - (id)mutableCopyWithZone:(NSZone *)zone
  {
      return _instance;
  }

  - (oneway void)release
  {
      // 为保证整个程序过程中只有一份实例, 
      // 在这个方法中什么都不做
  }

  - (instancetype)retain
  {
      return _instance;
  }

  - (NSUInteger)retainCount
  {
      // return 1;
      // 注意: 为了方便程序员之前沟通, 一般情况下不会在单例中返回retainCount = 1
      // 而是返回一个比较大得值
      return  MAXFLOAT;
  }
  @end

  
