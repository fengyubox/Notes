数据库操作
    创建数据库
        create database [if not exists] 数据库名称 [字符编码];

        示例一:
        在MySQL中创建一个名称叫做stu1的数据库
        create database stu1;
        注意点: 如果已经存在一个叫做stu1的数据库, 那么会报错

        示例二:
        判断如果没有stu1的库就创建, 有就不创建
        企业开发中推荐这样写
        create database if not exists stu1;

        示例三:
        创建一个数据库, 告诉MySQL将来数据库中存储的内容采用gbk编码
        create database if not exists stu2 charset=gbk;
        注意点:
        如果没有手动设置数据库的编码, 那么默认会采用安装时全局的设置作为默认的编码

    查看数据库全局默认的编码
        show variables like 'character_set_%';

    查看某个数据库的编码
        show create database 数据库名称;

    特殊的数据库名称处理
        如果数据库的名称是SQL语句的关键字或者是特殊符号, 那么数据库的名称需要用反引号括起来
        create database if not exists create charset=utf8; #报错
        create database if not exists `create` charset=utf8; #不会报错
        create database if not exists `#%~*%#` charset=utf8; #不会报错

    删除数据库
        drop database [if exists] 数据库名称;

        示例一:
        drop database stu1;
        注意点: 如果数据库不存在会报错

        示例二:
        判断只有表存在才删除, 不存在就不删除
        drop database if exists stu1;

    查看数据库
        show databases;

    修改数据库
        alter database 数据库名称 charset=字符编码

        示例:
        alter database stu2 charset=utf8;

表操作
    创建表
        create table [if not exists] 表名(
            字段名称 数据类型 [null | not null],
            字段名称 数据类型 [auto_increment],
            字段名称 数据类型 [primary key],
            字段名称 数据类型 [default],
            字段名称 数据类型 [comment]
        )engine=存储引擎;

        字段名称: 相当于Excel中每一列的名称
        数据类型: 相当于Excel中每一列的数据类型

        [null | not null] 该字段是否可以为空, 默认都可以为空
        [auto_increment] 该字段的值自动增长
            1 自增长字段的值从1开始, 每次递增1
            2 自增长字段数据不可以重复, 合适生成唯一的id
            3 自增长字段可以使用null或者default来设置值
            4 自增长字段必须是主键 (primary key)
        [primary key] 主键, 一张表中只能有一个主键
            主键用于唯一标识表中的每一条数据, 和现实生活中的身份证很像
            主键的特征: 不能重复, 不能为空
            注意点:
                auto_increment的字段必须是主键, 但是主键不一定是auto_increment的, 只要是唯一的就可以
                如果主键不是自增长的, 那么不能为空
                一个表只能有一个主键, 但是主键可以是1个或多个字段组成
                    联合主键的应用场景:
                        如果一张表无论哪一个字段都无法保证数据的唯一性,
                        可以使用多个字段组合再一起保证数据的唯一性
                    create table if not exists stu5(
                        id1 int,
                        id2 int,
                        name varchar(20),
                        #不是指定两个主键, 一个primary key就是指定一个主键
                        #这里只出现了一个primary key, 所以只指定了一个主键
                        #只不过这个主键比较特殊, 是由两个字段共同组成的
                        primary key(id1,id2)
                    );
            可以在创建表之后再添加主键
                create table if not exists stu6(
                    id int,
                    name varchar(20)
                );
                alter table stu6 add primary key(id);
            企业开发中如何选择主键?
                1. 最少性: 尽量选择一个字段作为主键
                2. 稳定性: 尽量选择更新少的字段作为主键
                3. 尽量选择整数类型的字段作为主键
                4. 结论: 搞一个id字段类型为int, 设置自动增长, 作为主键
        [unique] 唯一键
            避免添加重复数据, 也就是说如果想保证某一个字段的值永远不重复, 那么就可以将这个字段设置为唯一键
            唯一键不是主键, 主键有一个特点是不能重复, 但是唯一键不等于主键
            一张表中只能有一个主键, 但是一张表中可以有多个唯一键
            删除唯一键
                alter table 表名 drop index 唯一键名;
                alter table stu11 drop index name; #删除唯一键
        [default] 默认值, 如果没有传递对应的值, 就使用默认值
        [comment] 备注, 方便程序员之间沟通
        存储引擎  innodb/myisam/memory

        注意点:
        由于一个MySQL中可以有很多数据库, 所以在创建表之前必须告诉MySQL要创建到哪一个数据库中

        示例一:
        use person;
        create table stu(
            id int,
            name varchar(20)
        );
        上面语句的含义: 在person数据库中创建一张叫做stu的表, 表中有两个字段, 分别是id和name, id将来可以存储int类型的值, name将来可以存储字符串类型的值

        示例二: 企业开发推荐写法
        use person;
        create table if not exists stu(
            id int,
            name varchar(20)
        );
    
    查看数据库中的表
        show tables;
    
    查看表的结构
        desc[ribe] 表名;

    删除表
        drop table [if exists] 表名1, 表名2, ....;

        示例一:
        drop table stu;
        注意点: 表不存在会报错

        示例二:
        drop table if exists stu;

        示例三:
        drop table if exists stu1,stu2;
    
    修改表
        添加字段
            alter table 表名 add 字段名 数据类型 [位置];

            示例一:
            会将新的字段添加到原有字段的最后
            alter table stu3 add email varchar(30);

            示例二:
            会将新的字段添加到原有字段的最前面
            alter table stu3 add phone int first;

            示例三:
            会将新的字段添加到指定字段的后面
            alter table stu3 add addr varchar(100) after name;

        删除字段
            alter table 表名 drop 字段名;

            示例一:
            alter table stu3 drop name;
    
        修改字段
            alter table 表名 change 原始字段名 新字段名 数据类型;

            示例一:
            改字段名称, 并且改字段的类型
            alter table stu3 change addr age int;

            示例二:
            改字段的类型, 不改字段的名称
            alter table stu3 modify phone varchar(20);
    
    修改存储引擎
        数据库的本质就是文件
        只要新建一个数据库, 就会自动创建一个文件夹
        只要删除一个数据库, 就会自动删除一个文件夹

        alter table 表名 engine=引擎名称;

        innodb: 默认
            create table stu(
                id int,
                name varchar(20)
            );
            create table stu1(
                id int,
                name varchar(20)
            )engine=innodb;
            指定存储引擎为innodb和不指定引擎创建表生成的文件夹都一样, 所以推断出默认使用的就是innodb存储引擎
            innodb存储引擎只要创建一张表就会自动创建一个后缀为frm的文件
            注意:
                .frm文件不是存储表中的数据的, 数据会存储到ibdata1中, 如果数据比较多系统会自动创建ibdata2, ibdata3, ....
                .frm文件是MySQL表结构定义文件
        
        myisam:
            create table stu2(
                id int,
                name varchar(20)
            )engine=myisam;
            指定存储引擎为myisam, 只要创建一张表就会自动创建三个文件
                .frm文件是MySQL表结构定义文件
                .MYD文件存储表的数据
                .MYI文件存储表的索引

        memory:
            create table stu3(
                id int,
                name varchar(20)
            )engine=memory;
            指定存储引擎为memory; 只要创建一张表就会自动创建一个文件
                .frm文件是MySQL表结构定义文件
            注意点:
                memory会将数据存储到内存中, 一旦电脑重启数据就不见了
                特点读写比较快, 但是不会永久存储
    
    修改表名
        alter table 原始名称 rename to 新名称;

    表复制
        复制数据, 但不复制结构
            create table 新表名 select 字段 from 旧表名;
            create table newStu select * from stu5;
        复制结构, 但不复制数据
            create table 新表名 like 旧表名;
            create table newStu2 like stu5;

数据操作
    插入数据
        insert into 表名 (字段名1, 字段名2, ...) values (值1, 值2, ....);

        示例一:
        create table if not exists stu(
            id int,
            name varchar(20)
        );
        insert into stu (id, name) values (1, 'lnj');
        # 字段名称不用和表中的顺序一致
        insert into stu (name, id) values ('zq', 2);
        # 值顺序和个数必须和字段的顺序个数一致
        insert into stu (name, id) values ('ww');
        insert into stu (name, id) values (3, 'ww');
        # 如果值的顺序和个数和表中字段的顺序和个数一致, 那么字段名称可以省略
        insert into stu values (3, 'ww');
        # 一次性插入多条数据, 每条数据的值用逗号隔开
        insert into stu values (4, 'it'), (5, 'zb');

        create table if not exists stu2(
            name varchar(20) not null,
            score int default 59,
            age int
        );
        # 被not null修饰的字段必须传值
        insert into stu2 (score, age) values (88, 13); #报错

        默认字段都是被null修饰的, 所以可以不传值
        如果字段被default修饰, 那么不传值就会使用默认值
        insert into stu2 (name) values ('lnj'); #不报错

        default用于告诉MySQL使用默认值
        insert into stu2 (name, score, age) values ('zs', default, 13);

        create table if not exists stu3(
            id  int auto_increment primary key,
            name varchar(20)
        );
        被auto_increment修饰的字段, 会从1开始自动增长
        给auto_increment修饰的字段传递null或者default, 都是使用默认自增长的值
        企业开发一般传递null, default用于告诉MySQL使用默认值
        insert into stu3 (id, name) values (null, 'lnj');
        insert into stu3 (id, name) values (default, 'zq');

    查询表中的数据
        select 字段名1,字段名2 from 表名 where 条件;

        # 查询指定字段的所有数据
        select name from stu5;
        # 查询多个制定字段的所有数据, 会按照查询时指定的字段顺序返回
        select name, id from stu5;
        # 如果需要查询所有字段, 可以用*代替字段名称
        select id, name, age from stu5;
        select * from stu5;
        # 查询所有满足条件的数据
        select * from stu5 where age>=40;
    
    更新数据
        update 表名 set 字段名=值 [where 条件];

        示例一:
        # 如果没有指定条件会修改表中所有的数据
        update stu2 set age=66;

        # 修改所有满足条件的数据
        update stu2 set age=88 where name='zs';

        # 添加多个条件 AND === &&  OR === ||
        update stu2 set age=44 where name='zs' AND score=98;

        # 同时修改多个字段的值
        update stu2 set score=100,name='it' where age=66;

    删除数据
        delete from 表名 where 条件;

        示例一:
        # 删除满足条件的所有数据
        delete from stu2 where age=88;
        delete from stu2 where age<66;

        # 删除表中所有的数据
        delete from stu2;

        delete from 表名; 删除表中所有的数据
        truncate table 表名; 清空表中所有的数据
        如果通过delete删除表中所有的数据, 自增长的字段不会被清空(插入新的数据自增长字段不会从1开始)
        本质是遍历表中的每一条数据, 逐条删除
        如果通过truncate清空表中所有的数据, 自增长的字段会被清空(插入新的数据自增长字段会从1开始)
        本质是将原有的表删除, 然后再创建一个一模一样的

MySQL中的中文问题
    默认情况下插入中文会报错
    但是报错的原因不在于插入的是否是中文
    而是因为插入数据的时候本质上是从客户端将插入语句发送到了MySQL服务器,
    MySQL服务器接收到插入语句之后再执行插入语句
    如果客户端是以GBK发送的, 而服务端是以UTF8接收的, 那么就会报错(不能识别)
    查看服务器编解码字符集
        show variables like 'character_set_%';
        +--------------------------+------------------------------------+
        | Variable_name            | Value                              |
        +--------------------------+------------------------------------+
        | character_set_client     | utf8    以什么字符集接收客户端发送的数据 |
        | character_set_connection | utf8                               |
        | character_set_database   | utf8                               |
        | character_set_filesystem | binary                             |
        | character_set_results    | utf8   以什么字符集给客户端发送数据     |
        | character_set_server     | utf8                               |
        | character_set_system     | utf8                               |
        | character_sets_dir       | D:\Developer\MySQL\share\charsets\ |
        +--------------------------+------------------------------------+
    将客户端和MySQL服务器的编码设置为一样的即可
    可以通过set names gbk;来修改MySQL的字符集
    set names gbk;会自动修改MySQL服务器接收和返回的编码方式

表数据类型
    整型
        TINYINT	      1 字节	(-128，127)	(0，255)	小整数值
        SMALLINT	  2 字节	(-32 768，32 767)	(0，65 535)	大整数值
        MEDIUMINT	  3 字节	(-8 388 608，8 388 607)	(0，16 777 215)	大整数值
        INT或INTEGER  4 字节	(-2 147 483 648，2 147 483 647)	(0，4 294 967 295)	大整数值
        BIGINT	      8 字节	(-9 233 372 036 854 775 808，9 223 372 036 854 775 807)	(0，18 446 744 073 709 551 615)	极大整数值
        注意点:
            和编程开发中的整型一样, 也区分有符号的整型和无符号的整型 unsigned, 默认就是有符号, 如果是无符号, 那么取值范围*2
            在企业开发中也和编程开发中, 每一个字段最好使用合适的类型
                例如存储人的年龄, 就不要使用INT,
            通过desc看到的数据类型后面的数值并不是占用的存储空间大小, 而是二printf一样,是位宽
                例如:  tinyint(4) 显示的宽度是4
                默认宽度不会自动填充, 如果想自动填充, 必须加上zerofill
                    create table if not exists stu4(
                        id int auto_increment primary key,
                        score TINYINT(2) unsigned ZEROFILL
                    );
            如果存储的值超出了取值范围, 那么会报错
    浮点类型
        FLOAT(m, d)	    4 字节	单精度
        DOUBLE(m, d)	8 字节	双精度
        m总位数, d小数位数

        float和double的区别
            和编程开发中一样, 默认保留的小数位数不同
            和编程开发中一样, 有效精度也不同
            和编程开发中一样, 浮点类型是不准确的,太长了可能丢失精度
            所以在企业开发中千万不要使用浮点数来保存用户的准确(珍贵)信息(RMB)
    定点类型
        decimal(M, D)
        m总位数, d小数位数
        定点类型的本质: 
            是将数据分为两个部分来存储, 每个部分都是整数
            所以可以保证精度
            但是定点数不要滥用, 因为非常消耗资源
    字符类型
        CHAR(size)	    0-255字节	    定长字符串
        VARCHAR(size)	0-65535 字节	变长字符串
        注意点: 
            由于是字符类型, 所以传递值只能用单引号''
            如果没有指定长度, 那么默认char就是255,varchar65535
            理论上varchar最多能够存储65535个字符, 但是实际的大小和表的编码方式有关
            如果表的编码方式是UTF-8, 那么最多能够存储65535/3
            如果表的编码方式是GBK, 那么最多能够存储65535/2

        MySQL中每一行数据的大小限制
            注意点: 在MySQL中每一行数据最多只能存储65535个字节
            create table if not exists stu12(
                cls char(2),
                name varchar(32767) #会报错, 所有列的总大小超过了65535
            )charset=gbk;

            create table if not exists stu12(
                cls char(2),
                name varchar(32764) #只要所有列的中大小不超过65535就可以创建
            )charset=gbk;

        char(2)和varchar(2)的区别:
            它们最多都只能保存2个字符
            char(2)不会回收多余的字符, 指定多少个就给我们多少个
            varchar(2)会回收多余的字符, 用多少给多少
            由于char(2)不会回收多余的字符, 所以效率高
            由于varchar(2)会回收多余的字符, 所以效率相对低一些
    大文本类型
        TINYTEXT	0-255字节	短文本字符串
        TEXT	    0-65535字节	长文本数据
        MEDIUMTEXT	0-16777215字节	中等长度文本数据
        LONGTEXT	0-4294967295字节	极大文本数据

        注意点:
            大文本类型在表中并不会实际占用所能保存的字节数, 而是利用10个字节引用了实际保存数据的地址
    枚举类型
        和编程开发中一样, 如果某个字段只能是固定的几个取值,并且只能是其中一个取值, 那么就可以使用枚举
        和编程开发中一样, MySQL中的枚举类型本质也是整型, 但是是从1开始的
        和编程开发中一样, 既然本质是整型, 所以就可以设置整型数据
        create table if not exists stu14(
            cls char(2),
            gender enum('男', '女', '妖')
        );
        insert into stu14 values(null, '未知'); #会报错, 只能设置枚举中列举的值
        insert into stu14 values(null, 1); #插入整型, 但是也必须在范围内
        select gender+0 from stu14; # +0表示以整形方式显示
    集合类型
        和编程开发中一样, 如果某个字段只能是固定的几个取值,并且可以是其中某几个取值, 那么就可以使用集合类型
        MySQL中的集合本质也是整型

        create table if not exists stu15(
            cls char(2),
            hobby set('篮球', '足球', '棒球', '足浴')
        );
        insert into stu15 values(null, '高尔夫'); #会报错, 只能设置集合中列举的值
        insert into stu15 values(null, '足球'); #插入一个值
        insert into stu15 values(null, '足球,篮球'); #插入多个值
        select hobby+0 from stu15; # +0表示以整形方式显示

        底层整形的计算公式是2(n), n从0开始
        2(0) === 1;
        2(1) === 2;
        2(2) === 4;
    日期类型:
        DATE	    3字节	YYYY-MM-DD	日期值
        TIME	    3字节	HH:MM:SS	时间值或持续时间
        DATETIME	8字节	YYYY-MM-DD HH:MM:SS	混合日期和时间值

        create table if not exists stu16(
            id int auto_increment primary key,
            field1 date,
            field2 time,
            field3 datetime
        );
        insert into stu16 (field1) values ('2020-12-12');
        insert into stu16 (field1) values ('2020/12/12');
        insert into stu16 (field1) values ('202/12/12'); #内部会自动补全 0202/12/12
        insert into stu16 (field2) values ('18:32:15');
        insert into stu16 (field2) values ('2020/12/12 18:32:15');
    布尔类型
        注意: MySQL不支持真正的布尔类型, 由于MySQL是用C/C++编写的, 所以非零即真
        和C语言一样, ture===1 , false===0
        create table if not exists stu17(
            id int auto_increment primary key,
            field1 boolean,
            field2 boolean
        );
        insert into stu17 values (null, true, false);

单表查询
    字段表达式
        select 语句;

        select 6*6; #字段名称为6*6,字段值为36
        select 6*6 as mul; #为字段名称起别名
        select 6*6 mul2; #为字段名称起别名
    
        以上语句虽然可以执行, 但是看上去不符合MySQL查询语句的规范
        如果想要执行字段表达式, 又想要符合MySQL查询语句的规范, 那么可以使用伪表
        什么是伪表(dual)? 占位符,但是实际上什么都不会做
        select 6*6 mul from dual;
    
    where子语句
        在MySQL中where子语句支持简单的运算符
        > < >= <= = != and or not

    in | not in
        示例一:
        需求: 要求找出表中城市在北京和武汉的人
        过去的做法:
        弊端如果需要查找的城市太多, 语句会变得很冗余
        select * from stu where city='北京' or city='武汉';
        如果需要查找的城市太多, 可以利用in来简化语句
        select * from stu where city in ('北京', '武汉');

        示例二:
        需求: 要求找出表中城市不在北京和武汉的人
        select * from stu where city!='北京' and city!='武汉';
        select * from stu where city not in ('北京', '武汉');
    
    between...and | not between...and
        示例一:
        需求: 要求找出表中年龄在17~23岁之间的人
        select * from stu where age>=17 and age<=23;
        select * from stu where age between 17 and 23;

        示例二:
        需求: 要求找出表中年龄不在17~23岁之间的人
        select * from stu where age<17 or age>23;
        select * from stu where age not between 17 and 23;
    
    is null | is not null
        注意点: 在MySQL中判断某一个字段保存的数据是否为null不能用等于符号

        select * from stu where age=18;
        insert into stu (name) values('it66');
        select * from stu where age is null;
        select * from stu where age is not null;
    
    模糊查询
        _通配符: 表示任意一个字符
        %通配符: 表示任意0~n个字符

        a_c: abc, adc
        abc,adc,abbc,ac
        _a_c: 1abc,3adc
        1abc,abc1,2abbc,3adc

        a%c:abc, adc,abbc, ac
        abc,adc,abbc,ac
        %a%c:1abc,2abbc, 3adc
        1abc,abc1,2abbc,3adc

        格式:
            select 字段 from 表名 where 字段 like '条件';

            select * from stu where name like 'z_c';
            select * from stu where name like 'z%';
    
    排序 order by
        格式:
            select 字段 from 表名 order by 字段 [asc | desc]
            
        示例一:
        select * from stu order by age; #默认是升序排序
        select * from stu order by age asc; #升序
        select * from stu order by age desc; #降序

        示例二:
        insert into stu values(null, 'itzb', 23, 100, '广州');
        需求: 按照年龄升序排序, 如果年龄相同那么按照成绩降序排序

        select * from stu order by age asc, score desc;