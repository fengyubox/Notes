特殊变量
    $?	上个命令的退出状态，或函数的返回值
    $$	当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID

sh -x nginx.sh  # -x可以看到脚本的执行过程

变量替换
    variable_1="I love you,Do you love me"
    1. ${变量#匹配规则}	         从头开始匹配，最短删除
        var1=${variable_1#*ov}   "e you,Do you love me"
    2. ${变量##匹配规则}         从头开始匹配，最长删除
        var2=${variable_1##*ov}  "e me"
    3. ${变量%匹配规则}	         从尾开始匹配，最短删除
        var3=${variable_1%ov*}   "I love you,Do you l"
    4. ${变量%%匹配规则}         从尾开始匹配，最长删除
        var4=${variable_1%%ov*}  "I l"
    5. ${变量/旧字符串/新字符串}  替换变量内的旧字符串为新字符串，只替换第一个
        var5=${PATH/bin/BIN}
    6. ${变量//旧字符串/新字符串} 替换变量内的旧字符串为新字符串，全部替换
        var6=${PATH//bin/BIN}

变量测试
    配置方式            str没有配置    str为空串    str已配置且非空
    var=${str-expr}    var=expr      var=        var=$str
    var=${str:-expr}   var=expr      var=expr    var=$str
    var=${str+expr}    var=          var=expr    var=expr
    var=${str:+expr}   var=          var=        var=expr
    var=${str=expr}    var=expr      var=        var=$str
    var=${str:=expr}   var=expr      var=expr    var=$str

字符串处理
    1 计算字符串长度
        ${#string}
            len=${#var1}
        expr length $string
            len=`expr length "$string"`
    2 获取字符索引位置
        expr index "$string" substr  下标从1开始
            var1="quickstart is a app"
            ind=`expr index "$var1" start`  # 6
            ind=`expr index "$var1" uniq`   # 1 
                # 背后其实是uniq切成4个字符去查找,哪个最先找到索引就为他,这里q第一个就可以被找到,所以返回1
    3 获取子串长度
        expr match "$string" substr  必须子串开头
            var1="quicstart is a app"
			sub_len=`expr match "$var1" app`     # 0,因为不是以app开头 
            sub_len=`expr match "$var1" quic.*`  # 18
    4 抽取字符串中的子串
        方法一 下标从0开始
            1 ${string:position}
            2 ${string:position:length}
            3 ${string: -position} 或者 ${string:(position)} 使用括号前面就不需加空格
                
            var1="kafka hadoop yarn mapreduce"
            
            substr1=${var1:10}     # "op yarn mapreduce"
            substr2=${var1:10:5}   # "op ya"
            substr3=${var1: -5}    # "educe"
            substr3=${var1:(-5)}   # "educe"
            substr4=${var1: -5:2}  # "ed"
        方法二 下标从1开始
            expr substr $string $position $length
                substr5=`expr substr "$var1" 10 5`  # "oop y"

数组的用法：
	array=("Allen" "Mike" "Messi" "Jerry" "Hanmeimei" "Wang")
	
	打印元素：			echo ${array[2]}
	打印元素个数:		echo ${#array[@]}
	打印元素长度：		echo ${#array[3]}
	给元素赋值：		array[3]="Li"
	删除元素：			unset array[2];unset array
	分片访问：			echo ${array[@]:1:3}
	元素内容替换：		${array[@]/e/E}	只替换第一个e;${array[@]//e/E}	替换所有的e
	数组的遍历：
		for a in ${array[@]}
		do
			echo $a
		done

命令替换
    1. `command`
            获取系统的所有用户并输出	
                index=1
                
                for user in `cat /etc/passwd | cut -d ":" -f 1`
                do
                    echo "This is $index user: $user"
                    # 在Linux的shell中，变量的值的类型默认是字符串，不能直接进行数值运算
                    # 所以这里使用双括号来enable数值运算
                    index=$(($index + 1))
                done
    2. $(command)
            根据系统时间计算今年或明年
			    echo "This is $(date +%Y) year"
			    echo "This is $(($(date +%Y) + 1)) year"
            
            根据系统时间获取今年还剩下多少星期，已经过了多少星期
                date +%j
                echo "This year have passed $(date +%j) days"
                echo "This year have passed $(($(date +%j)/7)) weeks"
                
                echo "There is $((365 - $(date +%j))) days before new year"
                echo "There is $(((365 - $(date +%j))/7)) weeks before new year"
        
            判定nginx进程是否存在，若不存在则自动拉起该进程
                # grep -v 排除(invert match)
                nginx_process_num=$(ps -ef | grep nginx | grep -v grep | wc -l)
                
                if [ $nginx_process_num -eq 0 ];then
                    systemctl start nginx
                fi
    
    ``和$()两者是等价的，但推荐初学者使用$()，易于掌握；缺点是极少数UNIX可能不支持，但``都是支持的
    $(())主要用来进行整数运算，包括加减乘除,引用变量前面可以加$，也可以不加$
        num1=20;num2=30
        echo "$(($num1 + $num2))" # 120
        echo "$((num1 + num2))"   # 120
    自增自减操作
        num=0
        ((num++))
		((num--))

有类型变量
    1. declare -r	# 声明变量为只读类型
        declare -r var="hello"
		var="world"		# -bash: var: readonly variable
    2. declare -i	# 声明变量类型为整型
        num1=10
        declare -i num2
        num2=$num1+1
        echo $num2  # 11
    3. declare -f	# 在脚本中显示系统定义的函数和内容
    4. declare -F	# 在脚本中显示系统定义的函数
    5. declare -a   # 声明变量为数组 下标从0开始
        declare -a array
        array=("jones" "mike" "kobe" "jordan")

        输出数组内容
            echo ${array[@]}	输出全部内容
		    echo ${array[1]}	输出下标索引为1的内容
        获取数组长度
            echo ${#array}		数组内元素个数
			echo ${#array[2]}	数组内下标索引为2的元素长度
        给数组某个下标赋值
            array[0]="lily"		    给数组下标索引为1的元素赋值为lily
			array[20]="hanmeimei"	在数组尾部添加一个新元素
        删除元素
            unset array[2]		清除元素
			unset array			清空整个数组
        分片访问
            ${array[@]:1:4}		显示数组下标索引从1开始到3的3个元素，不显示索引为4的元素
        内容替换
            ${array[@]/an/AN}	将数组中所有元素内包含an的子串替换为AN
        数组遍历
            for v in ${array[@]}
            do
                echo $v
            done
    6. declare -x   # 声明为环境变量，可以在脚本中直接使用
        num5 = 30
        declare -x num5

    取消声明的变量
        declare +r
        declare +i
        declare +a
        declare +x

数学运算之expr  
    num1=20
    num2=100
    
    # \用于转义
    # 是返回1,否返回0,跟shell命令运行结果刚好相反
    expr $num1 \| $num2
    expr $num1 \& $num2
    expr $num1 \< $num2
    expr $num1 \< $num2
    expr $num1 \<= $num2
    expr $num1 \> $num2
    expr $num1 \>= $num2
    expr $num1 = $num2
    expr $num1 != $num2
    expr $num1 + $num2
    expr $num1 - $num2
    expr $num1 \* $num2
    expr $num1 / $num2
    expr $num1 % $num2

    提示用户输入一个正整数num，然后计算1+2+3+...+num的值；
    必须对num是否为正整数做判断，不符合应当允许再此输入

    while true
    do
        read -p "Pls enter a positive integer(num>0): " num

        // 判断变量是否为正数
        expr $num + 1 &> /dev/null
        // 不为0时报错
        if [ $? -ne 0 ];then
            echo "Error,You must input a interger"
            continue
        else
            if [ `expr $num \> 0` -ne 1 ];then
                echo "Error,You must input a postive interger"
                continue
            else
                sum=0
                for((i=0;i<=$num;i++))
                do
                    sum=`expr $sum + $i`
                done
                echo "1+2+3+4+5+...+$num=$sum"
            fi
        fi
    done

数学运算之bc 支持浮点数
    echo "options;expression" | bc
    
    num1=23.5
    num2=50
    
    # scale指定精度,否则会当整数处理
    var1=`echo "scale=2;$num1 * $num2" | bc`

函数定义和使用
    函数定义的两种语法
        1. 
            name()
            {
                command1
                command2
                .....
                commandn
            }
        2.
            function name
            {
                command1
                command2
                .....
                commandn
            }
    函数使用
        调用函数直接使用函数名即可，相当于一条命令
    向函数传递参数
        函数传参和给脚本传参类似，都是使用$1 $2 $3 $4 $5 $6 $7这种方式
    函数返回值
        使用return返回值 
            只能返回1-255的整数
            通常返回1或0,0表示成功,1表示失败
            this_pid=$$

            function is_nginx_running
			{

				ps -ef | grep nginx | grep -v $this_pid | grep -v grep > /dev/null 2>&1
				if [ $? -eq 0 ];then
					return 0  # 只写return等同于return 0
				else
					return 1
				fi
			}

			is_nginx_running && echo "Nginx is running" || echo "Nginx is stopped"
        使用echo返回值
            通常用于返回数据
            function add
			{
				echo "`expr $1 \+ $2`"
			}

			sum=`add $1 $2`
    局部变量和全局变量
        要点1：Shell脚本中，默认所有变量都是全局变量；即使函数内部定义的变量，一旦函数调用后，改变了就将一直存在，直到脚本执行完毕
		要点2：定义局部变量，使用local关键字；
		要点3：函数内部，变量会自动覆盖外部变量

        编程习惯原则：
			1、尽量在函数内部使用local关键字，将变量的作用于限制在函数内部
			2、命名变量名时尽可能遵循实义性的，尽量做到见名知意
    函数库
        将经常使用的重复代码封装成函数文件
        一般不直接执行,而是由其他脚本调用
        库文件的后缀是任意的,但一般使用.lib
        库文件通常没有可执行选项
        第一行一般使用#!/bin/echo,输出警告信息,避免用户执行
        在脚本中,通过 . 库文件名的绝对路径 即可导入库中的函数 e.g. . base_function

文件查找
    文件查找之find
        find [路径] [选项] [操作]
        常用选项
            -name			查找/etc目录下以conf结尾的文件	find /etc -name '*conf'
            -iname			查找当前目录下文件名为aa的文件，不区分大小写	find . -iname aa
            -user			查找文件属主为hdfs的所有文件	find . -user hdfs
            -group			查找文件属组为yarn的所有文件	find . -group yarn		
            -type			
                f		文件				find . -type f 
                d		目录				find . -type d
                c		字符设备文件		find . -type c
                b		块设备文件			find . -type b
                l		链接文件			find . -type l
                p		管道文件			find . -type p
            -size
                -n		小于大小n的文件
                +n		大于小于n的文件
                例子1：查找/etc目录下小于10000字节的文件		find /etc -size -10000c
                例子2：查找/etc目录下大于1M的文件				find /etc -size +1M
            -mtime		
                -n		n天以内修改的文件
                +n		n天以外修改的文件
                n		正好n天修改的文件
                例子1：查找/etc目录下5天之内修改且以conf结尾的文件	find /etc -mtime -5 -name '*.conf'
                例子2：查找/etc目录下10天之前修改且属主为root的文件	find /etc -mtime +10 -user root
            -mmin
                -n		n分钟以内修改的文件
                +n		n分钟以外修改的文件
                例子1：查找/etc目录下30分钟之前修改的文件		find /etc -mmin +30
                例子2：查找/etc目录下30分钟之内修改的目录		find /etc -mmin -30 -type d
            -mindepth n		表示从n级子目录开始搜索
                例子：在/etc下的3级子目录开始搜索		find /etc -mindepth 3 
            -maxdepth n		表示最多搜索到n级子目录
                例子1：在/etc下搜索符合条件的文件，但最多搜索到2级子目录		find /etc -maxdepth 3 -name '*.conf'
                例子2：
                    find ./etc/ -type f -name '*.conf' -size +10k -maxdepth 2
        了解选项
            -nouser		查找没有属主的用户
                例子：find . -type f -nouser
            -nogroup	查找没有属组的用户
                例子：find . -type f -nogroup
            -perm
                例子：find . -perm 664
            -prune
                通常和-path一起使用，用于将特定目录排除在搜索条件之外
                例子1：查找当前目录下所有普通文件，但排除etc目录
                    find . -path ./etc -prune -o -type f
                例子2：查找当前目录下所有普通文件，但排除etc和opt目录
                    find . -path ./etc -prune -o -path ./opt -prune -o -type f
                例子3：查找当前目录下所有普通文件，但排除etc和opt目录，但属主为hdfs
                    find . -path ./etc -prune -o -path ./opt -prune -o -type f -a -user hdfs
                例子4：查找当前目录下所有普通文件，但排除etc和opt目录，但属主为hdfs，且文件大小必须大于500字节
                    find . -path ./etc -prune -o -path ./opt -prune -o -type f -a -user hdfs -a -size +500c
            -newer file1
                例子：find /etc -newer a
        操作
            -print		打印输出
            -exec		对搜索到的文件执行特定的操作，格式为-exec 'command' {} \;
                例子1：搜索/etc下的文件(非目录)，文件名以conf结尾，且大于10k，然后将其删除
                    find ./etc/ -type f -name '*.conf' -size +10k -exec rm -f {} \;
                例子2：将/var/log/目录下以log结尾的文件，且更改时间在7天以上的删除
                    find /var/log/ -name '*.log' -mtime +7 -exec rm -rf {} \;
                例子3：搜索条件和例子1一样，只是不删除，而是将其复制到/root/conf目录下
                    find ./etc/ -size +10k -type f -name '*.conf' -exec cp {} /root/conf/ \;
            -ok			和exec功能一样，只是每次操作都会给用户提示
        逻辑运算符
            -a			与
            -o			或
            -not|!		非
            例子1：查找当前目录下，属主不是hdfs的所有文件		
                find . -not -user hdfs 	|	find . ! -user hdfs
            例子2：查找当前目录下，属主属于hdfs，且大小大于300字节的文件
                find . -type f -a -user hdfs -a -size +300c
            例子3：查找当前目录下的属主为hdfs或者以xml结尾的普通文件
                find . -type f -a \( -user hdfs -o -name '*.xml' \)

    文件查找之locate
        不同于find命令是在整块磁盘中搜索,locate命令在数据库文件中查找
        find默认是全部匹配(精确匹配),locate则是默认部分匹配
        强制更新数据库文件(/var/lib/mlocate/mlocate.db)
            updatedb // 该命令本身在后台cron计划中定期执行
        updatedb配置文件,用于配置放哪些文件在数据库中
            /etc/updatedb.conf

    文件查找之whereis
        默认会查找二进制文件,帮助文档文件,源代码文件
        -b 只返回二进制文件
        -m 只返回帮助文档文件
        -s 只返回源代码文件
        e.g. whereis mysql

    文件查找之which
        仅查找二进制程序文件

    文件查找总结
        find 功能强大,速度慢
        locate 功能单一,只能查找单个文件,速度快
        whereis 不常用
        which 常用于查找程序的绝对路径

grep和egrep
    两种使用形式
        1. grep [option] [pattern] [file1,file2...]
        2. command | grep [option] [pattern] 
    必须掌握的选项
        -v		显示不匹配pattern的行
        -i		搜索时忽略大小写
        -n		显示行号
        -E		支持扩展的正则表达式
        -F		不支持正则表达式，按字符串的字面意思进行匹配
        -r		递归搜索
    需了解的选项：
        -c		只输出匹配行的数量，不显示具体内容
        -w		匹配整词
        -x		匹配整行
        -l		只列出匹配的文件名，不显示具体匹配行内容
    grep和egrep：
		grep默认不支持扩展正则表达式，只支持基础正则表达式
		使用grep -E可以支持扩展正则表达式
		使用egrep可以支持扩展正则表达式，与grep -E等价

sed
    sed是流编辑器，依据特定的匹配模式
    对文本逐行匹配，并对匹配行进行特定处理

    两种使用形式
        1. stdout | sed [option] "/pattern/command"
        2. sed [option] "/pattern/command" file

    选项
        -n 只打印模式匹配行 
            默认会打印匹配的原行信息加命令之后的信息
            -n只打印匹配命令之后的信息
        -e 直接在命令行进行sed编辑,默认选项
            用于指定多个编辑命令
            sed -n -e '/python/p' -e '/PYTHON/p' sed.txt
        -f 编辑动作保存在文件中,指定文件执行
            e.g. 
                创建edit.sed文件,内容为
                    /python/p
                调用
                    sed -n -f edit.sed sed.txt
        -r 支持扩展正则表达式
            sed -n -r '/python|PYTHON/p' sed.txt
        -i 直接修改文件内容
            # 多个command用;隔开
            sed -n -i 's/love/like/g;p' sed.txt
    
    命令
        查询
            p 打印特定的行
                sed [option] '/pattern/p' file
        删除
            d 删除
                用法总结
                    1. 1d
                    2. 5,10d
                    3. 10,+10d
                    4. /pattern1/d
                    5. /pattern1/,/pattern2/d
                    6. /pattern1/,20d
                    7. 15,/pattern1/d
        增加
            a 匹配到的行后追加内容
            i 匹配到的行前追加内容
            r 将后面指定文件的内容追加到匹配到的行后面
            w 将匹配到的行内容另存到其他文件中
        修改
            s/pattern/string/  
                查找并替换,查找符合pattern模式的字符串，将其替换为string  
                /后不跟数字默认只替换第一个,加数字可适配替换几个(1,2,3,4,5)
            s/pattern/string/g  g表示全部行内全部匹配
            s/pattern/string/2g  2g表示，同一行内，只替换从第2个开始到剩下所有的符合条件的字符串
            s/pattern/string/ig  加i参数表示匹配时忽略大小写，g表示匹配到的全部替换

            修改用法总结：
                1. 1s/old/new/
                2. 5,10s/old/new/
                3. 10,+10s/old/new/
                4. /pattern1/s/old/new/
                5. /pattern1/,/pattern2/s/old/new/
                6. /pattern1/,20s/old/new/
                7. 15,/pattern1/s/old/new/
        其他编辑命令
            =  显示行号
        反向引用
            &和\1	引用模式匹配到的整个串
                sed "s/l..e/&r/g" file		 在file中搜寻以l开头，然后跟两个任意字符，以e结尾的字符串，在找到的字符串后加r字符(后向引用)
                sed "s/\(l..e\)/\1r/g" file	 和上面实现一样的功能，使用\1代表搜寻到的字符串
                上面两种方式实现了一样的功能，分别使用&和\1引用前面匹配到的整个字符串
                两者区别在于&只能表示匹配到的完整字符串，只能引用整个字符串；而\1可以使用()对匹配到的字符串进行分组，可以替换完整字符串，也可以替换子串，更加灵活
                例如：如果我们仅想要替换匹配到的字符串的一部分，name必须使用\1这种方式，不能使用&。
                    查找test.txt文件中以l开头，紧接着跟两个任意字符，再接一个e的字符串。将找到的字符串中开头的小写l换成大写L
                    sed "s/l\(..e\)/L\1/g" test.txt

    pattern的几种形式
        1. LineNumber         直接指定行号
            # 打印file文件的第17行
			sed -n "17p" file	     
		2. StartLine,EndLine  指定起始行号和结束行号
            # 打印file文件的10到20行
			sed -n "10,20p" file    
		3. StartLine,+N	      指定起始行号，然后后面N行
            # 打印file文件中从第10行开始，往后面加5行的所有行
			sed -n "10,+5p" file    
		4. /pattern1/		  正则表达式匹配的行
            # 打印file文件中以root开头的行
			sed -n "/^root/p" file  
		5. /pattern1/,/pattern2/  从匹配到pattern1的行，到匹配到pattern2的行
            # 打印file文件中第一个匹配到以ftp开头的行，到第二个匹配到以mail开头的行
			sed -n "/^ftp/,/^mail/p" file			
		6. LineNumber,/pattern1/  从指定行号开始匹配，直到匹配到pattern1的行
            # 打印file文件中从第4行开始匹配，直到以hdfs开头的行匹配到就结束
			sed -n "4,/^hdfs/p" file				
		7. /pattern1/,LineNumber  从pattern1匹配的行开始，直到匹配到指定行号位置结束
            # 打印file文件中匹配root的行，直到第10行结束
			sed -n "/root/,10p" file				

    sed中引用变量时注意事项
        1. 匹配模式中存在变量，则建议使用双引号
            old_str=hadoop
            new_str=HADOOP
            sed -i "s/$old_str/$new_str/g" str.txt
        2. sed中需要引入自定义变量时，如果外面使用单引号，则自定义变量也必须使用单引号
            old_str=hadoop
            new_str=HADOOP
            sed -i 's/'$old_str'/'$new_str'/g' str.txt

awk
    是一个文本处理工具,通常用于处理数据并生成结果报告
    两种语法格式
        1. awk 'BEGIN{}pattern{commands}END{}'file_name
        2. standard output | awk 'BEGIN{}pattern{commands}END{}'
    内置变量
        $0					打印行所有信息
        $1~$n				打印行的第1到n个字段的信息
        NF	Number Field				处理行的字段个数,字段号从1开始
        NR	Number Row					处理行的行号,行号从1开始
        FNR	File Number Row				多文件处理时，每个文件单独记录行号
        FS	Field Separator				字段分割符，不指定时默认以空格或tab键分割
        RS	Row Separator				行分隔符，不指定时以回车分割\n
        OFS	 Output Filed Separator		输出字段分隔符
        ORS	 Output Row Separator		输出行分隔符
        FILENAME			处理文件的文件名
        ARGC				命令行参数个数
        ARGV				命令行参数数组
    格式化输出之printf
        格式符
			%s		打印字符串
			%d		打印10进制数
			%f		打印浮点数
			%x		打印16进制数
			%o		打印8进制数
			%e		打印数字的科学计数法格式
			%c		打印单个字符的ASCII码
		修饰符
			-		左对齐
			+		右对齐
			#		显示8进制在前面加0，显示16进制在前面加0x
    awk模式匹配
        两种用法
            1. RegExp
            2. 运算符匹配
                关系运算符匹配：
                    <			小于
                    >			大于
                    <=			小于等于
                    >=			大于等于
                    ==			等于
                    !=			不等于
                    ~			匹配正则表达式
                    !~			不匹配正则表达式
                布尔运算符匹配：
                    ||			或
                    &&			与
                    !			非
    awk动作中的表达式
        算数运算符
            +				加
            -				减
            *				乘
            /				除
            %				取模
            ^或**			乘方
            ++x				在返回x变量之前，x变量加1
            x++				在返回x变量之后，x变量加1
            --x				在返回x变量之前，x变量减1
            x--				在返回x变量之后，x变量减1
    awk动作中的条件及循环语句
        条件语句：
			if(条件表达式1)
				动作
			else if(条件表达式2)
				动作
			else
				动作
		循环语句：
			while循环:
				while(条件表达式)
					动作
			do while循环:
				do
					动作
				while(条件表达式)
			for循环:
				for(初始化计数器;计数器测试;计数器变更)
					动作
    awk中的字符串函数
        length(str)						计算长度
        index(str1,str2)				返回在str1中查询到的str2的位置
        tolower(str)					小写转换
        toupper(str)					大写转换	
        split(str,arr,fs)				分隔字符串，并保存到数组中
        match(str,RE)					返回正则表达式匹配到的子串的位置
        substr(str,m,n)					截取子串，从m个字符开始，截取n位。n若不指定，则默认截取到字符串尾
        sub(RE,RepStr,str)				替换查找到的第一个子串
        gsub(RE,RepStr,str)				替换查找到的所有子串
    awk中常用选项
		-v		定义或引用shell中的变量
            awk -v num2="$num1" -v var1="$var" 'BEGIN{print num2,var1}'
		-f		指定awk命令文件
		-F		指定分隔符
            awk -F: '{print $7}' /etc/passwd 
		-V		查看awk的版本号
    awk中数组的用法:
        awk中数组下标是从1开始计数
        在awk中，使用数组时，不仅可以使用1.2..n作为数组下标，也可以使用字符串作为数组下标
        当使用1.2.3..n时，直接使用array[2]访问元素;需要遍历数组时，使用以下形式：
            str="Allen Jerry Mike Tracy Jordan Kobe Garnet"
            split(str,array)
            for(i=1;i<=length(array);i++)
                print array[i]
        当使用字符串作为数组下标时，需要使用array[str]形式访问元素;遍历数组时，使用以下形式：
            array["var1"]="Jin"
            array["var2"]="Hao"
            array["var3"]="Fang"
            
            for(a in array)
                print array[a]