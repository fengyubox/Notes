GOROOT: SDK安装的目录
GOPATH: go源代码存放的目录
GOBIN: 将来编译的可执行程序存放的目录,GOBIN目录,必须放在GOPATH目录里面

go env // 查看go配置的环境变量
go install main.go // 将包编译并放到GOPATH下的bin(命令文件)或者pkg目录(非命令文件)
go run main.go // 将包编译并运行,但是会将编译后的文件放到临时目录而不是GOBIN下
go build // 编译检查当前目录下的go文件,如果不是命令文件(main.go)，那么执行完后不会产生文件,如果是命令文件,则在目录下产生一个编译好的二进制文件
go fmt // 格式化当前目录下的go文件

unsafe.Sizeof(int(0)) // 查看数据类型占用的内存大小

占位符使用
    %T 数据类型
    %t 布尔类型

全局变量定义了没有使用不会报错,定义常量没有使用不会报错

常量组中,如果常量没有赋值,默认值就是上一行取值
const(
    a = 666
    b = 789
    c  // 789
)

退化赋值
如果通过:=定义多个变量,但是多个变量中有的变量已经在前面定义过了,那么:=就只会做赋值操作,不会做定义操作
num := 123
num, value := 456, 789  // 结果为456, 789

GO语言中没有隐式转换,且不能对一个常量进行强制转换
var num float64 = 3.14
var value int = int(num)

GO语言中必须类型完全一样,才可以赋值(例如int32也不可转为int8)
但是有特殊情况
    1. byte -> uint8
    2. rune -> int32
bool类型不能强制转换为整形

strconv.FormatXxx() // 将基本数据类型转为字符串类型
strconv.Itoa() // 将int整形转换为字符串类型
strconv.ParseXxx() // 将字符串类型转为基本数据类型
strconv.Atoi() // 将字符串类型转为int整形

如果常量组中的iota被打断,但是后续又被恢复,那么前面有多少行就会递增多少
const(
    male = iota // 0
    female = 666
    yao = iota // 2
)

fmt.Scanf(格式化字符串, 地址列表) // 如果接收的不是字符串类型(%c),会忽略空格和TAB,但是不会忽略回车
fmt.Scanln(地址列表) // 如果接收的不是字符串类型(%c),会忽略空格和TAB,但是不会忽略回车
fmt.Scan(地址列表) // 如果接收的不是字符串类型(%c),会忽略空格,TAB,回车

接收命令行参数(main函数不接收任何参数)
    1. os.Args获取,获得的是一个数组,弊端就是无论传入是什么类型,最终获取到的都是字符串类型
    2. flag.StringVar IntVar ...
        var name string
        flag.StringVar(&name, name: "name", value: "默认的名称", usage: "请传递用户的姓名")
        flag.Parse() // 将编好的参数注册到命令行

        main.exe -name=lnj
    3. flag.String
        *name := flag.String(name: "name", value: "默认的名称", usage: "请传递用户的姓名")
        flag.Parse()

        main.exe -name=lnj

不同类型的常量可以进行运算
不同类型的变量不可以直接进行运算,要先转换类型
字符串可以用+拼接,但是不能与其他类型拼接,要先做类型转换
go中的++ --只能写在后面,不能写在前面
go中没有非零即真的概念,逻辑运算符或算数运算符两边的值都必须为布尔类型
go中多了一个位运算符&^, a &^ b,如果b的当前二进制位为1,那么就清零,否则就保留a的二进制位的数据

函数注意点
    1. 如果函数中有返回值,可以在返回值列表中定义变量,然后在函数体中直接使用
    2. 如果在返回值列表中定义了变量,那么return后面可以不用写任何内容,默认就会将返回值列表中定义的变量返回

如果在同一个函数中编写了多个defer语句,那么会遵守先进后出的原则

init函数的作用
    对当前文件进行初始化
    会在main函数之前调用

main包中程序执行调用顺序
    main包 -> 常量 -> 全局变量 -> init函数 -> main函数 -> 执行逻辑代码 -> Exit程序
其他包中执行流程
    常量 -> 全局变量 -> init函数 -> 执行逻辑代码
当包中导入另外一个包,就会先进入另外一个包的执行流程,然后返回继续当前包的流程

go中的数组可以先定义再一次性初始化(C语言不行)
    var ages [3]int
    ages = [3]int{1, 3, 5}
定义同时初始化
    1. 完全初始化
        var ages [3]int = [3]int{1, 3, 5}
    2. 部分初始化
        var ages [3]int = [3]int{1, 3}
    3. 指定元素初始化
        var ages [3]int = [3]int{2:5} //给下标为2的元素赋值5
    新版本中,定义同时初始化可以省略元素个数
        ages := []int{1, 3, 5}
    老版本中需要使用
        ages := [...]int{1, 3, 5}

数组在go语言中是一个值类型,所以数组之间的赋值是拷贝关系,而不是指向的关系
如果想让两个数组可以互相赋值,那么两个数组的类型必须一致
类型一致包括元素个数,元素个数也是Go中数组类型的一部分
如果数组中存储的元素类型支持==, ！=操作, 并且两个数组的类型是一样的, 那么数组也支持==, !=操作




