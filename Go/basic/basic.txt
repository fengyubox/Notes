GOROOT: SDK安装的目录
GOPATH: go源代码存放的目录
GOBIN: 将来编译的可执行程序存放的目录,GOBIN目录,必须放在GOPATH目录里面

go env // 查看go配置的环境变量
go install main.go // 将包编译并放到GOPATH下的bin(命令文件)或者pkg目录(非命令文件)
go run main.go // 将包编译并运行,但是会将编译后的文件放到临时目录而不是GOBIN下
go build // 编译检查当前目录下的go文件,如果不是命令文件(main.go)，那么执行完后不会产生文件,如果是命令文件,则在目录下产生一个编译好的二进制文件
go fmt // 格式化当前目录下的go文件

unsafe.Sizeof(int(0)) // 查看数据类型占用的内存大小

占位符使用
    %T 数据类型
    %t 布尔类型

全局变量定义了没有使用不会报错,定义常量没有使用不会报错

常量组中,如果常量没有赋值,默认值就是上一行取值
const(
    a = 666
    b = 789
    c  // 789
)

退化赋值
如果通过:=定义多个变量,但是多个变量中有的变量已经在前面定义过了,那么:=就只会做赋值操作,不会做定义操作
num := 123
num, value := 456, 789  // 结果为456, 789

GO语言中没有隐式转换,且不能对一个常量进行强制转换
var num float64 = 3.14
var value int = int(num)

GO语言中必须类型完全一样,才可以赋值(例如int32也不可转为int8)
但是有特殊情况
    1. byte -> uint8
    2. rune -> int32
bool类型不能强制转换为整形

strconv.FormatXxx() // 将基本数据类型转为字符串类型
strconv.Itoa() // 将int整形转换为字符串类型
strconv.ParseXxx() // 将字符串类型转为基本数据类型
strconv.Atoi() // 将字符串类型转为int整形

如果常量组中的iota被打断,但是后续又被恢复,那么前面有多少行就会递增多少
const(
    male = iota // 0
    female = 666
    yao = iota // 2
)

fmt.Scanf(格式化字符串, 地址列表) // 如果接收的不是字符串类型(%c),会忽略空格和TAB,但是不会忽略回车
fmt.Scanln(地址列表) // 如果接收的不是字符串类型(%c),会忽略空格和TAB,但是不会忽略回车
fmt.Scan(地址列表) // 如果接收的不是字符串类型(%c),会忽略空格,TAB,回车

接收命令行参数(main函数不接收任何参数)
    1. os.Args获取,获得的是一个数组,弊端就是无论传入是什么类型,最终获取到的都是字符串类型
    2. flag.StringVar IntVar ...
        var name string
        flag.StringVar(&name, name: "name", value: "默认的名称", usage: "请传递用户的姓名")
        flag.Parse() // 将编好的参数注册到命令行

        main.exe -name=lnj
    3. flag.String
        *name := flag.String(name: "name", value: "默认的名称", usage: "请传递用户的姓名")
        flag.Parse()

        main.exe -name=lnj

不同类型的常量可以进行运算
不同类型的变量不可以直接进行运算,要先转换类型
字符串可以用+拼接,但是不能与其他类型拼接,要先做类型转换
go中的++ --只能写在后面,不能写在前面
go中没有非零即真的概念,逻辑运算符或算数运算符两边的值都必须为布尔类型
go中多了一个位运算符&^, a &^ b,如果b的当前二进制位为1,那么就清零,否则就保留a的二进制位的数据

函数注意点
    1. 如果函数中有返回值,可以在返回值列表中定义变量,然后在函数体中直接使用
    2. 如果在返回值列表中定义了变量,那么return后面可以不用写任何内容,默认就会将返回值列表中定义的变量返回

如果在同一个函数中编写了多个defer语句,那么会遵守先进后出的原则

init函数的作用
    对当前文件进行初始化
    会在main函数之前调用

main包中程序执行调用顺序
    main包 -> 常量 -> 全局变量 -> init函数 -> main函数 -> 执行逻辑代码 -> Exit程序
其他包中执行流程
    常量 -> 全局变量 -> init函数 -> 执行逻辑代码
当包中导入另外一个包,就会先进入另外一个包的执行流程,然后返回继续当前包的流程

go中的数组可以先定义再一次性初始化(C语言不行)
    var ages [3]int
    ages = [3]int{1, 3, 5}
定义同时初始化
    1. 完全初始化
        var ages [3]int = [3]int{1, 3, 5}
    2. 部分初始化
        var ages [3]int = [3]int{1, 3}
    3. 指定元素初始化
        var ages [3]int = [3]int{2:5} //给下标为2的元素赋值5
   定义同时初始化可以省略元素个数
        ages := [...]int{1, 3, 5}
        

数组在go语言中是一个值类型,所以数组之间的赋值是拷贝关系,而不是指向的关系
如果想让两个数组可以互相赋值,那么两个数组的类型必须一致
类型一致包括元素个数,元素个数也是Go中数组类型的一部分
如果数组中存储的元素类型支持==, ！=操作, 并且两个数组的类型是一样的, 那么数组也支持==, !=操作

二维数组也可以省略元素个数,但是只能省略行数,不能省略列数(新版本也可以省略列数)

ages := []int{1, 3, 5} // 代表切片
只要数组的[]中没有编写数字,那么就不是一个数组,是一个切片
切片不支持== !=操作
创建切片
    1. 通过数组创建
        var ages [5]int = {1, 3, 5, 7, 9}
        var sce []int = ages[0:2] // 不包括结束位置下标
        len(sce) // 计算切片当前保存数据的个数
        cap(sce) // 计算切片总共可以保存数据的个数,等于数组的长度减去起始位置
        如果只写了起始位置,没有写结束位置,会截取到最后
        如果只写了结束位置,没有写起始位置,会从开始截取到指定的结束位置
        如果只写了:,那么就是从开始截取到结尾
    2. 通过make函数创建
        var sce []int = make([]int, 2, 5)
        第三个参数cap可以省略,如果省略,cap的容量就等于len(第二个参数)
    3. 通过go提供的语法糖创建(len等于cap)
        var sce []int = []int{1, 3, 5}
    
如果像使用数组一样使用切片,那么索引的长度不能超过切片的len
append(切片, 数据) // 在len后面追加数据
如果通过append函数追加后超过了原有的容量,那么会自动按照当前容量*2的方式重新定义一个数组作为切片保存数据的模型
这里注意如果容量小于1024的时候扩容,会按照2倍,但是当超过1024之后,会按照0.25倍扩容
append函数要返回一个切片的原因是因为在扩容的时候会重新定义一个新的切片,所以要返回一个切片

copy(目的切片, 源切片) 
拷贝时会以目标切片为主,所以只会拷贝目的切片长度的数据如果源切片长度大于目的切片,
如果目的切片长度大于源切片那么就覆盖掉源切片长度的值,剩下的依旧使用目的切片的值

删除切片中的元素
    index := 2
    sce = append(sce[:index], sce[index + 1:]...)

直接打印切片的变量名代表获取切片中数组指针保存的位置
    var sce []int = arr[:]
    fmt.Printf("%p", sce)

可变参数,底层就是一个切片,并且可变参数只能放在函数形参列表的最后
    sum(10, 20, 30)
    func sum(num ...int) int {
        ...
    }
    背后其实就等于是
    func sum(nums []int) int {
        ...
    }

字符串的底层是[]byte数组,如果想要修改字符串的某个字符(当然拷贝完的对象不是源对象了,是一个新的对象)
    var str string = "jahaha"
    sce := make([]byte, len(str))
    copy(sce, str)
    sce[0] = 'M'
    fmt.Printf("%s\n", sce)


