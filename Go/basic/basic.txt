GOROOT: SDK安装的目录
GOPATH: go源代码存放的目录
GOBIN: 将来编译的可执行程序存放的目录,GOBIN目录,必须放在GOPATH目录里面

go env // 查看go配置的环境变量
go install main.go // 将包编译并放到GOPATH下的bin(命令文件)或者pkg目录(非命令文件)
go run main.go // 将包编译并运行,但是会将编译后的文件放到临时目录而不是GOBIN下
go build // 编译检查当前目录下的go文件,如果不是命令文件(main.go)，那么执行完后不会产生文件,如果是命令文件,则在目录下产生一个编译好的二进制文件
go fmt // 格式化当前目录下的go文件

unsafe.Sizeof(int(0)) // 查看数据类型占用的内存大小

占位符使用
    %T 数据类型
    %t 布尔类型

全局变量定义了没有使用不会报错,定义常量没有使用不会报错

常量组中,如果常量没有赋值,默认值就是上一行取值
const(
    a = 666
    b = 789
    c  // 789
)

退化赋值
如果通过:=定义多个变量,但是多个变量中有的变量已经在前面定义过了,那么:=就只会做赋值操作,不会做定义操作
num := 123
num, value := 456, 789  // 结果为456, 789

GO语言中没有隐式转换,且不能对一个常量进行强制转换
var num float64 = 3.14
var value int = int(num)

GO语言中必须类型完全一样,才可以赋值(例如int32也不可转为int8)
但是有特殊情况
    1. byte -> uint8
    2. rune -> int32
bool类型不能强制转换为整形

strconv.FormatXxx() // 将基本数据类型转为字符串类型
strconv.Itoa() // 将int整形转换为字符串类型
strconv.ParseXxx() // 将字符串类型转为基本数据类型
strconv.Atoi() // 将字符串类型转为int整形

如果常量组中的iota被打断,但是后续又被恢复,那么前面有多少行就会递增多少
const(
    male = iota // 0
    female = 666
    yao = iota // 2
)

fmt.Scanf(格式化字符串, 地址列表) // 如果接收的不是字符类型(%c),会忽略空格和TAB,但是不会忽略回车
fmt.Scanln(地址列表) // 如果接收的不是字符类型(%c),会忽略空格和TAB,但是不会忽略回车
fmt.Scan(地址列表) // 如果接收的不是字符类型(%c),会忽略空格,TAB,回车

接收命令行参数(main函数不接收任何参数)
    1. os.Args获取,获得的是一个数组,弊端就是无论传入是什么类型,最终获取到的都是字符串类型
    2. flag.StringVar IntVar ...
        var name string
        flag.StringVar(&name, name: "name", value: "默认的名称", usage: "请传递用户的姓名")
        flag.Parse() // 将编好的参数注册到命令行

        main.exe -name=lnj
    3. flag.String
        *name := flag.String(name: "name", value: "默认的名称", usage: "请传递用户的姓名")
        flag.Parse()

        main.exe -name=lnj

不同类型的常量可以进行运算
不同类型的变量不可以直接进行运算,要先转换类型
字符串可以用+拼接,但是不能与其他类型拼接,要先做类型转换
go中的++ --只能写在后面,不能写在前面
go中没有非零即真的概念,逻辑运算符或算数运算符两边的值都必须为布尔类型
go中多了一个位运算符&^, a &^ b,如果b的当前二进制位为1,那么就清零,否则就保留a的二进制位的数据

函数注意点
    1. 如果函数中有返回值,可以在返回值列表中定义变量,然后在函数体中直接使用
    2. 如果在返回值列表中定义了变量,那么return后面可以不用写任何内容,默认就会将返回值列表中定义的变量返回

如果在同一个函数中编写了多个defer语句,那么会遵守先进后出的原则

init函数的作用
    对当前文件进行初始化
    会在main函数之前调用

main包中程序执行调用顺序
    main包 -> 常量 -> 全局变量 -> init函数 -> main函数 -> 执行逻辑代码 -> Exit程序
其他包中执行流程
    常量 -> 全局变量 -> init函数 -> 执行逻辑代码
当包中导入另外一个包,就会先进入另外一个包的执行流程,然后返回继续当前包的流程

go中的数组可以先定义再一次性初始化(C语言不行)
    var ages [3]int
    ages = [3]int{1, 3, 5}
定义同时初始化
    1. 完全初始化
        var ages [3]int = [3]int{1, 3, 5}
    2. 部分初始化
        var ages [3]int = [3]int{1, 3}
    3. 指定元素初始化
        var ages [3]int = [3]int{2:5} //给下标为2的元素赋值5
   定义同时初始化可以省略元素个数
        ages := [...]int{1, 3, 5}
        

数组在go语言中是一个值类型,所以数组之间的赋值是拷贝关系,而不是指向的关系
如果想让两个数组可以互相赋值,那么两个数组的类型必须一致
类型一致包括元素个数,元素个数也是Go中数组类型的一部分
如果数组中存储的元素类型支持==, ！=操作, 并且两个数组的类型是一样的, 那么数组也支持==, !=操作

二维数组也可以省略元素个数,但是只能省略行数,不能省略列数(新版本也可以省略列数)

ages := []int{1, 3, 5} // 代表切片
只要数组的[]中没有编写数字,那么就不是一个数组,是一个切片
切片不支持== !=操作
创建切片
    1. 通过数组创建
        var ages [5]int = {1, 3, 5, 7, 9}
        var sce []int = ages[0:2] // 不包括结束位置下标
        len(sce) // 计算切片当前保存数据的个数
        cap(sce) // 计算切片总共可以保存数据的个数,等于数组的长度减去起始位置
        如果只写了起始位置,没有写结束位置,会截取到最后
        如果只写了结束位置,没有写起始位置,会从开始截取到指定的结束位置
        如果只写了:,那么就是从开始截取到结尾
        数组创建切片还可以使用 数组名称[low:high:max]
        注意max必须大于或等于high,如果指定了第三个参数,那么切片的容量就等于第三个参数减去第一个参数
    2. 通过make函数创建
        var sce []int = make([]int, 2, 5)
        第三个参数cap可以省略,如果省略,cap的容量就等于len(第二个参数)
    3. 通过go提供的语法糖创建(len等于cap)
        var sce []int = []int{1, 3, 5}
    
切片作为函数的参数,是地址传递(指针),在函数内修改形参,会影响到函数外的实参
如果定义了一个切片没有初始化,不可以使用下标赋值的方式赋值,数组可以
如果像使用数组一样使用切片,那么索引的长度不能超过切片的len
append(切片, 数据) // 在len后面追加数据
如果通过append函数追加后超过了原有的容量,那么会自动按照当前容量*2的方式重新定义一个数组作为切片保存数据的模型
这里注意如果容量小于1024的时候扩容,会按照2倍,但是当超过1024之后,会按照0.25倍扩容
append函数要返回一个切片的原因是因为在扩容的时候会重新定义一个新的切片,所以要返回一个切片

copy(目的切片, 源切片) 
拷贝时会以目标切片为主,所以只会拷贝目的切片长度的数据如果源切片长度大于目的切片,
如果目的切片长度大于源切片那么就覆盖掉源切片长度的值,剩下的依旧使用目的切片的值

删除切片中的元素
    index := 2
    sce = append(sce[:index], sce[index + 1:]...)

直接打印切片的变量名代表获取切片中数组指针保存的位置
    var sce []int = arr[:]
    fmt.Printf("%p", sce)

可变参数,底层就是一个切片,并且可变参数只能放在函数形参列表的最后
    sum(10, 20, 30)
    func sum(num ...int) int {
        ...
    }
    背后其实就等于是
    func sum(nums []int) int {
        ...
    }

字符串的底层是[]byte数组,如果想要修改字符串的某个字符(当然拷贝完的对象不是源对象了,是一个新的对象)
    var str string = "jahaha"
    sce := make([]byte, len(str))
    copy(sce, str)
    sce[0] = 'M'
    fmt.Printf("%s\n", sce)

清空控制台
cmd := exec.Command("cmd", "/c", "cls")
cmd.Stdout = os.Stdout
cmd.Run()

只要能够进行==, ！=操作的类型,都可以作为字典的key
初始化字典(没有初始化的字典是不能使用的,例如key赋值)
    1. 语法糖创建
        var dict map[int]int
        dict = map[int]int{0:1, 1:3, 2:5}
    2. 通过make创建(字典数据类型,长度),如果赋值超出长度会自动扩容
        var dict map[int]int
        dict = make(map[int]int, 3)
    3. 通过make创建(字典数据类型)
        var dict map[int]int
        dict = make(map[int]int)

字典查询
    value, ok = 字典名称[key]
    如果有对应的key,那么就会把key对应的值赋值给value,且ok等于true
    如果没有对应的key,那么value就等于零,且ok等于false
    
delete(字典变量, key) // 字典删除
字典保存的数据是无序的
字典之间的赋值和切片一样是地址传递
所以字典作为函数的参数,修改形参会影响到实参


结构体
    type Person struct {
        name string
        age int
    }

    var per Person
    per = Person{"desmond", 18} // 完全初始化
    per = Person{"desmond"} // 错误写法,部分初始化必须通过属性名称指定要给谁初始化
    per = Persion{name: "desmond"} // 正确写法

    结构体类型和数组类型一样,在GO语言中都是值传递

    如果结构体的属性是切片和字典类型,那么就不能直接操作(因为本身切片和字典就必须初始化才可以操作)
    必须先给切片或者字典初始化

    结构体变量之间可以互相转换,但是必须保证结构体类型的
    属性名称 属性类型 属性顺序 属性个数 都一样
    type Person1 struct {
        name string
        age int
    }
    type Person2 struct {
        name string
        age int
    }
    var p1 Person1 = Person1{}
    var p2 Person2
    p2= Person2(p1) // 必须保证以上条件才可以互相转换

    匿名结构体属性 没有名称的属性 
        go中的继承就是通过匿名属性来实现的
        type Person2 struct {
            int
            name string
        }
        var per Person = Person{666, "desmond"}

        匿名属性的数据类型就是匿名属性的名称,可以通过匿名属性的数据类型来操作
        var per Person
        per.int = 666

        一般用于结构体的嵌套定义
        type Date struct {
            year int 
            month int
            day int
        }

        type Person struct {
            name string
            Date
        }

    结构体嵌套定义的几种方式
        1. 
            type 结构体名称1 struct {
                结构体类型名称
            }
            type 结构体名称2 struct {
                结构体名称1
            }
            嵌套属性访问
                type Person struct {
                    name string
                    age int
                }
                type Student struct {
                    Person
                    score float32
                }

                stu := Student{Person{"zs", 18}, 99.5}
                1.
                    stu.Person.name
                2.
                    stu.name // 会在当前结构体中查找,如果没有就会进入嵌套的结构体中查找
                    当然如果当前结构体中已经有该属性名,那就必须显式指定
        2.
            type 结构体名称1 struct {
            }
            type 结构体名称2 struct {
                结构体名称1
            }
            type 结构体名称3 struct {
                结构体名称2
            }
            嵌套属性访问
                type Object struct {
                    name string
                }
                type Person struct {
                    Object
                    age int
                }
                type Student struct {
                    Person
                    score float32
                }

                stu := Student{Person{Object{"desmond"}, 18}, 99.5}
                1.
                    stu.Person.Object.name
                2.
                    // 会在当前结构体中查找,如果没有就会进入嵌套的结构体中查找
                    // 当然如果当前结构体中已经有该属性名,那就必须显式指定
                    stu.Person.name
                    stu.name 
        3.
            type 结构体名称1 struct {
            }
            type 结构体名称2 struct {
            }
            type 结构体名称3 struct {
                结构体名称1
                结构体名称2
            }
            嵌套属性访问
                type Object struct {
                    name string
                }
                type Person struct {
                    age int
                }
                type Student struct {
                    Object
                    Person
                    score float32
                }

                stu := Student{Object{"123"}, Person{"456"}, 99.5}
                1.
                    stu.Person.name
                    stu.Object.name
                2.
                    // 会在当前结构体中查找,如果没有就会进入嵌套的结构体中查找
                    // 当然如果当前结构体中已经有该属性名,那就必须显式指定
                    stu.Person.name
                    stu.Object.name
                    stu.name 
    结构体不可以嵌套自己的类型  
        // 以下定义错误
        type Person struct {
            Person // 如果是指针就可以,其实就是一个链表结构
            name string
        }
    只有匿名属性才会进入嵌套结构体中查找
        type Person struct {
            name string
            age int
        }
        type Student struct {
            per Person // 非匿名属性
            score float32
        }

        stu := Student{Person{"zs", 18}, 99.5}
        此时就不可以通过stu.name来获取Person结构体中的name


数组指针
    和C语言一样,只要一个指针指向数组之后,就可以通过指针来操作数组
        (*p)[0] 或者直接 p[0]
    go语言中指向数组的指针不支持+1 -1操作(C语言是支持的)
       *(p + 1) // 不支持
切片指针
    var sce []int = []int{1, 3, 5}
    如果直接sce的地址(%p),得到的是结构体中指向底层数组的指针保存的值
    如果&sce的地址(%p),得到的是切片结构体自己的地址
结构体指针
    注意和C语言一样可以省略*来操作结构体
    var p *Person
    p = &per
    (*p).name = "zs"
    也可以直接使用p.name = "zs"


Go方法与函数的区别在于方法是一种特殊的函数,它是和属性绑定在一起的,通常是结构体
方法只能通过绑定的数据类型对应的变量来调用
函数名称和方法名称可以重名
方法中接受者地址传递的两种方式
1. (指针变量名).方法名称()
2. 变量名.方法名称() // 这里在go语言中只要接受者是指针类型,那么编译器就会自动将普通变量的地址取出来传递给接受者


接口
专门用于定义函数的声明,也就是规定函数的形参,函数的返回值,函数的名称
接口只负责声明方法,只能通过和某种数据类型绑定的方法来实现,不能通过函数来实现
接口中不能出现同名的方法声明
只要某个数据类型实现了接口中声明的所有方法,那么就说这个数据类型实现了这个接口
只要一个数据类型实现了某个接口,那么就可以使用这个接口类型的变量来保存这个类型的数据
只要一个数据类型实现了某个接口,那么保存这个类型的数据之后,就可以使用接口类型变量调用接口中的方法
type 接口的名称 interface {
    函数的声明
}

接口可以嵌套,但是也是不能嵌套自己
type aer interface {
    start()
}
type ber interface {
    aer
    end()
}
// 可以将超集接口变量赋值给子集接口变量,当然前提是实现了两个接口的所有方法
// 但是不可以将子集赋值给超集
var b ber = Phone{"aaa"}
var a aer
a = b 
a.start()

go中的空接口,相当于其他语言的Object类型,可以充当任何类型
var value interface{}
value = 1
value = 3.14
...

空接口应用场景
    可以让数组和字典保存不同类型的数据

如果利用接口类型接受变量,那么接口类型的变量只能调用接口中定义的方法,不能调用数据类型中特有的方法和数据
想要访问的话必须进行类型转换,将接口类型转换为数据类型
1
    cm, ok := in.(Computer) // 将接口变量in进行类型转换
2  
    switch cm := in.(type) {
        case Computer:
            cm.say()
        default:
            fmt.Println("不是Computer类型")
    }

go中可以通过type给某种类型起一个别名
type 新类型名 原类型名
type 新类型名=原类型名
第一种方式代表定义了一个新的类型叫做'新类型名'
第二种方式代表给原类型名起了一个别名叫做'新类型名'
也就是说第一种方式定义的新类型和原类型在编译器看来是两个不同的类型
但是第二种方式对编译器来说是同一种类型


异常处理
    生成异常信息
        1. fmt.Errorf("error msg")
        2. errors.New("error msg")
    终止程序
        1. 系统自动终止
        2. panic("err msg") // 手动终止
    可以配合defer和recover来捕获异常,但是必须在panic抛出异常之前定义
    defer无论在函数正常或是异常都会执行
    recover可以捕获panic异常
        defer func() {
            if err: = recover(); err != nil {
                fmt.Println(err)
            }
        }()
    同一个函数如果有多个终止异常,只有第一个会被捕获


字符串
    len()用来获取字符串长度,获取的是字节数
    如果想通过len直接获取子的个数当有中文时,需要先将字符串转化为rune类型的切片
        str1 := "呆呆"
        var str2 []rune = []rune(str1)
        len := len(str2)
    strings.IndexByte(str1, 'c') // 查找指定字符在字符串中第一次出现的位置,没有返回-1,不能查中文
    strings.IndexRune(str1, '哈') // 类似IndexByte,但是可查找中文,查找逻辑中1个中文字占3个位置
    strings.IndexAny(str1, “6ic”) // 拆开“6ic”,一个一个去查找位置,并返回最前面的位置,中英文都可查
    stirngs.Index(str1, '6ic') // 和Any不同,是将'6ic'当成一个整体去查找
    strings.IndexFunc(str1, func(ch rune) bool {
        if ch == 'i' {
            return true
        }
        return false
    }) // 自定义方法进行字符串查询,背后就是将字符串转换成一个[]rune,然后遍历,自定义函数返回true就代表找到了
    上述方法前面加个Last就是逆向查找

    strings.Contains(str, "123") // 判断字符串是否包含子串
    strings.ContainsRune(str, '呆呆') // 判断字符串是否包含字符
    strings.ContainsAny(str, "123") // 拆开'123'只要任何一个字符在字符串中存在就返回true
    strings.HasPrefix(str, "123") // 判断字符串是否以指定字符串开头
    strings.HasSuffix(str, ".123") // 判断字符串是否以指定字符串结尾

    strings.Compare(str1, str2) // 比较两个字符串,相等返回0,第一个大于第二个返回1,反之返回-1
    strings.EqualFold(str1, str2) // 比较两个字符串是否相等,相等返回true反之返回false

    strings.ToUpper(str1) // 将字符串中小写字母转为大写
    strings.ToLower(str1) // 将字符串中大写字母转为小写
    strings.ToTitle(str1) // 将字符串中小写转为大写,不同语言下可能有不同的转换方式
    strings.Title(str1) // 将字符串中每个单词的首字母大写

    string.Split(str1, ",") // 切割字符串
    string.SplitN(str2, ",", 2) // 切割字符串,指定切割为几份
    string.SplitAfter(str2, ",") // 切割字符串,会保留分隔符
    string.SplitAfterN(str2, ",", 2) // 切割字符串,会保留分隔符,并且指定切割为几份

    strings.Fields(str) // 按空格切割,连续的空格按一个空格算
    strings.FieldsFunc(str, func(ch rune) bool {
        if ch == ’;‘ {
            return true
        }
        return false
    }) // 按函数指定的分割符切割,返回true表示满足切割条件

    sce := []string{"www", "it666", "com"}
    string.Join(sce, ".") // 合并字符串
    string.Repeat(str1, 3) // 按照指定的数目重复拼接成字符串
    string.Replace(str1, "abc", "www", 2) // 替换字符串,最后一个数字代表多个匹配时要替换几个,-1代表全部替换

    string.Trim(str, "123") // 清理掉字符串前后的指定子串(这里为123)
    string.TrimLeft(str, "123") // 清理掉字符串前的指定子串(这里为123) 
    string.TrimRight(str, "123") // 清理掉字符串后的指定子串(这里为123)
    string.TrimFunc(str, func(ch rune) bool {
        if ch == ’1‘ {
            return true
        }
        return false
    }) // 按函数指定的字符清理掉字符串前后,返回true表示满足清理条件
    string.TrimLeftFunc  string.TrimRightFunc类似
    string.TrimSpace(str) // 清理掉字符串前后的空格
    string.TrimPrefix(str, "123") // 清理字符串前缀
    string.TrimSuffix(str, "123") // 清理字符串后缀


正则表达式
    regx, err := regexp.Compile(表达式)
    regx.FindAllString(str, 1) // 查找字符串中匹配的正则,最后数字代表返回几个匹配到的,-1代表返回所有匹配


时间
    now := time.Now() // 获取当前时间
    now.Year()
    now.Month()
    ...
    now.Second()
    str := now.Format("2006/01/02 15:04:05") // 按照指定格式输出,注意这里这些数字都是固定的,格式是可以变的

    时间常量多用于Sleep
        time.Sleep(time.Second)

    时间戳多用于产生生成随机数的因子
        Unix()返回秒的时间戳 UnixNano()返回纳秒的时间戳
        rand.Seed(time.Now().Unix())
        res := rand.Intn(3) // 生成[0, 3)的随机int值,小于0会panic




