runtime.Gosched() // 让出当前的执行权限,之后还会恢复执行
runtime.Goexit() // 退出当前协程
num := runtime.NumCPU() // 返回CPU个数
// 设置同时可执行的最大CPU数,返回上一次设置的值
// Go1.8之后,系统会自动设置为最大值
num := runtime.GOMAXPROCS(1) 

var lock = sync.Mutext{} // 创建一个互斥锁
lock.Lock() // 添加锁(关门)
...
lock.Unlock() // 释放锁(开门)

channel和切片/字典非常相似,都可以用来存储数据,都需要make之后才能使用
var myCh chan int
// 创建一个容量为3,并且可以保存int类型数据的管道
// 和切片不同,在切片中make函数的第二个参数表示的是切片的长度,第三个参数才是指定切片的容量
// 但在管道中,make函数的第二个参数就是指定管道的容量,默认长度就是0
myCh := make(chan int, 3) 
myCh <- 被写入的数据 // 写入数据
<- myCh // 读入数据
len(myCh)
cap(myCh)

遍历管道
如果被遍历的管道没有关闭,那么就会报错
在企业开发中,一旦写完了数据,最好将管道关闭
只要管道被关闭了,那么for range循环就不会报错了,就会自动结束了
close(myCh)
for v:= range myCh {
    fmt.Println(v)
}
或者可以
close(myCh)
for {
    // 如果被遍历的管道没有关闭,那么会报错
    // 如果管道没有被关闭,那么会将true返回给ok,否则会将false返回给ok
    if v, ok := <-myCh; ok {
        fmt.Println(v)
    } else {
        break
    }
}

管道关闭之后就不能往管道中写入数据了
但是管道关闭之后还可以从管道中读取数据

在主线程中操作管道,写满了再写会报错,没有数据去读取也会报错,但是如果在协程中有写的声明,那么即便主线程可能没有数据编译器也不会报错
在协程中操作管道,如果写满了再写不会报错但是会阻塞,如果没有数据时就读取也不会报错但会阻塞
